/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const NDPI_API_VERSION: u32 = 0;
pub const NDPI_NUM_DEFAULT_ROOT_NODES: u32 = 512;
pub const NDPI_IPSEC_PROTOCOL_ESP: u32 = 50;
pub const NDPI_IPSEC_PROTOCOL_AH: u32 = 51;
pub const NDPI_GRE_PROTOCOL_TYPE: u32 = 47;
pub const NDPI_ICMP_PROTOCOL_TYPE: u32 = 1;
pub const NDPI_IGMP_PROTOCOL_TYPE: u32 = 2;
pub const NDPI_EGP_PROTOCOL_TYPE: u32 = 8;
pub const NDPI_OSPF_PROTOCOL_TYPE: u32 = 89;
pub const NDPI_VRRP_PROTOCOL_TYPE: u32 = 112;
pub const NDPI_SCTP_PROTOCOL_TYPE: u32 = 132;
pub const NDPI_IPIP_PROTOCOL_TYPE: u32 = 4;
pub const NDPI_ICMPV6_PROTOCOL_TYPE: u32 = 58;
pub const NDPI_PGM_PROTOCOL_TYPE: u32 = 113;
pub const NDPI_PIM_PROTOCOL_TYPE: u32 = 103;
pub const NDPI_MAJOR: u32 = 5;
pub const NDPI_MINOR: u32 = 0;
pub const NDPI_PATCH: u32 = 0;
pub const NDPI_MAX_DNS_REQUESTS: u32 = 48;
pub const NDPI_MIN_NUM_STUN_DETECTION: u32 = 8;
pub const NDPI_CIPHER_SAFE: u32 = 0;
pub const NDPI_CIPHER_WEAK: u32 = 1;
pub const NDPI_CIPHER_INSECURE: u32 = 2;
pub const NDPI_OPTIMAL_HLL_NUM_BUCKETS: u32 = 16;
pub const NDPI_MAX_NUM_TLS_APPL_BLOCKS: u32 = 8;
pub const NDPI_PROTOCOL_SIZE: u32 = 2;
pub const NDPI_PROTOCOL_STACK_SIZE: u32 = 8;
pub const NDPI_MAX_NUM_DISSECTORS: u32 = 288;
pub const NDPI_PPP_HDRLEN: u32 = 4;
pub const NDPI_IN_PKT_DIR_UNKNOWN: u32 = 0;
pub const NDPI_IN_PKT_DIR_C_TO_S: u32 = 1;
pub const NDPI_IN_PKT_DIR_S_TO_C: u32 = 2;
pub const NDPI_FLOW_BEGINNING_UNKNOWN: u32 = 0;
pub const NDPI_FLOW_BEGINNING_SEEN: u32 = 1;
pub const NDPI_FLOW_BEGINNING_NOT_SEEN: u32 = 2;
pub const NDPI_GIVEUP_GUESS_BY_PORT: u32 = 1;
pub const NDPI_GIVEUP_GUESS_BY_IP: u32 = 2;
pub const NDPI_AGGRESSIVENESS_DISABLED: u32 = 0;
pub const NDPI_AGGRESSIVENESS_OOKLA_TLS: u32 = 1;
pub const NDPI_HEURISTICS_OPENVPN_OPCODE: u32 = 1;
pub const NDPI_HEURISTICS_TLS_OBFUSCATED_PLAIN: u32 = 1;
pub const NDPI_HEURISTICS_TLS_OBFUSCATED_TLS: u32 = 2;
pub const NDPI_HEURISTICS_TLS_OBFUSCATED_HTTP: u32 = 4;
pub const NDPI_PROTOCOL_DEFAULT_LEVEL: u32 = 0;
pub const NDPI_SERIALIZER_DEFAULT_HEADER_SIZE: u32 = 1024;
pub const NDPI_SERIALIZER_DEFAULT_BUFFER_SIZE: u32 = 256;
pub const NDPI_SERIALIZER_DEFAULT_BUFFER_INCR: u32 = 1024;
pub const NDPI_SERIALIZER_STATUS_COMMA: u32 = 1;
pub const NDPI_SERIALIZER_STATUS_ARRAY: u32 = 2;
pub const NDPI_SERIALIZER_STATUS_EOR: u32 = 4;
pub const NDPI_SERIALIZER_STATUS_SOB: u32 = 8;
pub const NDPI_SERIALIZER_STATUS_NOT_EMPTY: u32 = 16;
pub const NDPI_SERIALIZER_STATUS_LIST: u32 = 32;
pub const NDPI_SERIALIZER_STATUS_SOL: u32 = 64;
pub const NDPI_SERIALIZER_STATUS_HDR_DONE: u32 = 128;
pub const NDPI_SERIALIZER_STATUS_CEOB: u32 = 256;
pub const NDPI_RANKING_VERSION: u32 = 1;
pub const NDPI_DETECTION_ONLY_IPV4: u32 = 1;
pub const NDPI_DETECTION_ONLY_IPV6: u32 = 2;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_int = ::std::os::raw::c_uint;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __gnuc_va_list = __builtin_va_list;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub _short_backupbuf: [::std::os::raw::c_char; 1usize],
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused3: ::std::os::raw::c_int,
    pub _total_written: __uint64_t,
    pub _unused2: [::std::os::raw::c_char; 8usize],
}
impl _IO_FILE {
    #[inline]
    pub fn _flags2(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set__flags2(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _flags2_raw(this: *const Self) -> ::std::os::raw::c_int {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set__flags2_raw(this: *mut Self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(_flags2: ::std::os::raw::c_int) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let _flags2: u32 = unsafe { ::std::mem::transmute(_flags2) };
            _flags2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type va_list = __gnuc_va_list;
pub type u_char = __u_char;
pub type u_int = __u_int;
pub type time_t = __time_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_UNKNOWN: ndpi_protocol_id_t = 0;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FTP_CONTROL: ndpi_protocol_id_t = 1;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_POP: ndpi_protocol_id_t = 2;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_SMTP: ndpi_protocol_id_t = 3;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_IMAP: ndpi_protocol_id_t = 4;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DNS: ndpi_protocol_id_t = 5;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IPP: ndpi_protocol_id_t = 6;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HTTP: ndpi_protocol_id_t = 7;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MDNS: ndpi_protocol_id_t = 8;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NTP: ndpi_protocol_id_t = 9;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NETBIOS: ndpi_protocol_id_t = 10;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NFS: ndpi_protocol_id_t = 11;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SSDP: ndpi_protocol_id_t = 12;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BGP: ndpi_protocol_id_t = 13;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SNMP: ndpi_protocol_id_t = 14;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_XDMCP: ndpi_protocol_id_t = 15;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SMBV1: ndpi_protocol_id_t = 16;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SYSLOG: ndpi_protocol_id_t = 17;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DHCP: ndpi_protocol_id_t = 18;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_POSTGRES: ndpi_protocol_id_t = 19;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MYSQL: ndpi_protocol_id_t = 20;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MS_OUTLOOK: ndpi_protocol_id_t = 21;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VK: ndpi_protocol_id_t = 22;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_POPS: ndpi_protocol_id_t = 23;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TAILSCALE: ndpi_protocol_id_t = 24;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX: ndpi_protocol_id_t = 25;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NTOP: ndpi_protocol_id_t = 26;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_COAP: ndpi_protocol_id_t = 27;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VMWARE: ndpi_protocol_id_t = 28;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_SMTPS: ndpi_protocol_id_t = 29;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DTLS: ndpi_protocol_id_t = 30;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_UBNTAC2: ndpi_protocol_id_t = 31;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BFCP: ndpi_protocol_id_t = 32;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX_MAIL: ndpi_protocol_id_t = 33;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX_MUSIC: ndpi_protocol_id_t = 34;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GNUTELLA: ndpi_protocol_id_t = 35;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EDONKEY: ndpi_protocol_id_t = 36;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BITTORRENT: ndpi_protocol_id_t = 37;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MSTEAMS_CALL: ndpi_protocol_id_t = 38;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SIGNAL: ndpi_protocol_id_t = 39;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MEMCACHED: ndpi_protocol_id_t = 40;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SMBV23: ndpi_protocol_id_t = 41;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MINING: ndpi_protocol_id_t = 42;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NEST_LOG_SINK: ndpi_protocol_id_t = 43;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MODBUS: ndpi_protocol_id_t = 44;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WHATSAPP_CALL: ndpi_protocol_id_t = 45;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DATASAVER: ndpi_protocol_id_t = 46;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_XBOX: ndpi_protocol_id_t = 47;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_QQ: ndpi_protocol_id_t = 48;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TIKTOK: ndpi_protocol_id_t = 49;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTSP: ndpi_protocol_id_t = 50;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_IMAPS: ndpi_protocol_id_t = 51;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ICECAST: ndpi_protocol_id_t = 52;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CPHA: ndpi_protocol_id_t = 53;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IQIYI: ndpi_protocol_id_t = 54;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZATTOO: ndpi_protocol_id_t = 55;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX_MARKET: ndpi_protocol_id_t = 56;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX_DISK: ndpi_protocol_id_t = 57;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DISCORD: ndpi_protocol_id_t = 58;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ADOBE_CONNECT: ndpi_protocol_id_t = 59;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MONGODB: ndpi_protocol_id_t = 60;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PLURALSIGHT: ndpi_protocol_id_t = 61;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX_CLOUD: ndpi_protocol_id_t = 62;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OCSP: ndpi_protocol_id_t = 63;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VXLAN: ndpi_protocol_id_t = 64;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IRC: ndpi_protocol_id_t = 65;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MERAKI_CLOUD: ndpi_protocol_id_t = 66;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_JABBER: ndpi_protocol_id_t = 67;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NATS: ndpi_protocol_id_t = 68;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMONG_US: ndpi_protocol_id_t = 69;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YAHOO: ndpi_protocol_id_t = 70;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DISNEYPLUS: ndpi_protocol_id_t = 71;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HART_IP: ndpi_protocol_id_t = 72;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_VRRP: ndpi_protocol_id_t = 73;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_STEAM: ndpi_protocol_id_t = 74;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MELSEC: ndpi_protocol_id_t = 75;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WORLDOFWARCRAFT: ndpi_protocol_id_t = 76;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TELNET: ndpi_protocol_id_t = 77;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_STUN: ndpi_protocol_id_t = 78;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IPSEC: ndpi_protocol_id_t = 79;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_GRE: ndpi_protocol_id_t = 80;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_ICMP: ndpi_protocol_id_t = 81;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_IGMP: ndpi_protocol_id_t = 82;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_EGP: ndpi_protocol_id_t = 83;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_SCTP: ndpi_protocol_id_t = 84;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_OSPF: ndpi_protocol_id_t = 85;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_IP_IN_IP: ndpi_protocol_id_t = 86;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTP: ndpi_protocol_id_t = 87;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RDP: ndpi_protocol_id_t = 88;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VNC: ndpi_protocol_id_t = 89;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TUMBLR: ndpi_protocol_id_t = 90;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TLS: ndpi_protocol_id_t = 91;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SSH: ndpi_protocol_id_t = 92;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_USENET: ndpi_protocol_id_t = 93;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MGCP: ndpi_protocol_id_t = 94;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IAX: ndpi_protocol_id_t = 95;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TFTP: ndpi_protocol_id_t = 96;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AFP: ndpi_protocol_id_t = 97;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX_METRIKA: ndpi_protocol_id_t = 98;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX_DIRECT: ndpi_protocol_id_t = 99;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SIP: ndpi_protocol_id_t = 100;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TRUPHONE: ndpi_protocol_id_t = 101;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_ICMPV6: ndpi_protocol_id_t = 102;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DHCPV6: ndpi_protocol_id_t = 103;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ARMAGETRON: ndpi_protocol_id_t = 104;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CROSSFIRE: ndpi_protocol_id_t = 105;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DOFUS: ndpi_protocol_id_t = 106;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BLACKNUT: ndpi_protocol_id_t = 107;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BOOSTEROID: ndpi_protocol_id_t = 108;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GUILDWARS2: ndpi_protocol_id_t = 109;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMAZON_ALEXA: ndpi_protocol_id_t = 110;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KERBEROS: ndpi_protocol_id_t = 111;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LDAP: ndpi_protocol_id_t = 112;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NEXON: ndpi_protocol_id_t = 113;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MSSQL_TDS: ndpi_protocol_id_t = 114;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PPTP: ndpi_protocol_id_t = 115;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_AH: ndpi_protocol_id_t = 116;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_ESP: ndpi_protocol_id_t = 117;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SLACK: ndpi_protocol_id_t = 118;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FACEBOOK: ndpi_protocol_id_t = 119;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TWITTER: ndpi_protocol_id_t = 120;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DROPBOX: ndpi_protocol_id_t = 121;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GMAIL: ndpi_protocol_id_t = 122;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_MAPS: ndpi_protocol_id_t = 123;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YOUTUBE: ndpi_protocol_id_t = 124;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MOZILLA: ndpi_protocol_id_t = 125;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE: ndpi_protocol_id_t = 126;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MS_RPCH: ndpi_protocol_id_t = 127;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NETFLOW: ndpi_protocol_id_t = 128;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SFLOW: ndpi_protocol_id_t = 129;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HTTP_CONNECT: ndpi_protocol_id_t = 130;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HTTP_PROXY: ndpi_protocol_id_t = 131;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CITRIX: ndpi_protocol_id_t = 132;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NETFLIX: ndpi_protocol_id_t = 133;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LASTFM: ndpi_protocol_id_t = 134;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WAZE: ndpi_protocol_id_t = 135;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YOUTUBE_UPLOAD: ndpi_protocol_id_t = 136;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HULU: ndpi_protocol_id_t = 137;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CHECKMK: ndpi_protocol_id_t = 138;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AJP: ndpi_protocol_id_t = 139;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE: ndpi_protocol_id_t = 140;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WEBEX: ndpi_protocol_id_t = 141;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WHATSAPP: ndpi_protocol_id_t = 142;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE_ICLOUD: ndpi_protocol_id_t = 143;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VIBER: ndpi_protocol_id_t = 144;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE_ITUNES: ndpi_protocol_id_t = 145;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RADIUS: ndpi_protocol_id_t = 146;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WINDOWS_UPDATE: ndpi_protocol_id_t = 147;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TEAMVIEWER: ndpi_protocol_id_t = 148;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EGD: ndpi_protocol_id_t = 149;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HCL_NOTES: ndpi_protocol_id_t = 150;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SAP: ndpi_protocol_id_t = 151;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GTP: ndpi_protocol_id_t = 152;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WSD: ndpi_protocol_id_t = 153;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LLMNR: ndpi_protocol_id_t = 154;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TOCA_BOCA: ndpi_protocol_id_t = 155;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SPOTIFY: ndpi_protocol_id_t = 156;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FACEBOOK_MESSENGER: ndpi_protocol_id_t = 157;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_H323: ndpi_protocol_id_t = 158;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPENVPN: ndpi_protocol_id_t = 159;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NOE: ndpi_protocol_id_t = 160;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CISCOVPN: ndpi_protocol_id_t = 161;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TEAMSPEAK: ndpi_protocol_id_t = 162;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TOR: ndpi_protocol_id_t = 163;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SKINNY: ndpi_protocol_id_t = 164;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTCP: ndpi_protocol_id_t = 165;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RSYNC: ndpi_protocol_id_t = 166;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ORACLE: ndpi_protocol_id_t = 167;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CORBA: ndpi_protocol_id_t = 168;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CANONICAL: ndpi_protocol_id_t = 169;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WHOIS_DAS: ndpi_protocol_id_t = 170;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SD_RTN: ndpi_protocol_id_t = 171;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOCKS: ndpi_protocol_id_t = 172;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NINTENDO: ndpi_protocol_id_t = 173;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTMP: ndpi_protocol_id_t = 174;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FTP_DATA: ndpi_protocol_id_t = 175;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WIKIPEDIA: ndpi_protocol_id_t = 176;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZMQ: ndpi_protocol_id_t = 177;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMAZON: ndpi_protocol_id_t = 178;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EBAY: ndpi_protocol_id_t = 179;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CNN: ndpi_protocol_id_t = 180;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MEGACO: ndpi_protocol_id_t = 181;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RESP: ndpi_protocol_id_t = 182;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PINTEREST: ndpi_protocol_id_t = 183;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OSPF: ndpi_protocol_id_t = 184;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TELEGRAM: ndpi_protocol_id_t = 185;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_COD_MOBILE: ndpi_protocol_id_t = 186;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PANDORA: ndpi_protocol_id_t = 187;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_QUIC: ndpi_protocol_id_t = 188;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZOOM: ndpi_protocol_id_t = 189;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EAQ: ndpi_protocol_id_t = 190;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OOKLA: ndpi_protocol_id_t = 191;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMQP: ndpi_protocol_id_t = 192;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KAKAOTALK: ndpi_protocol_id_t = 193;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KAKAOTALK_VOICE: ndpi_protocol_id_t = 194;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TWITCH: ndpi_protocol_id_t = 195;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DOH_DOT: ndpi_protocol_id_t = 196;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WECHAT: ndpi_protocol_id_t = 197;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MPEGTS: ndpi_protocol_id_t = 198;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SNAPCHAT: ndpi_protocol_id_t = 199;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SINA: ndpi_protocol_id_t = 200;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_MEET: ndpi_protocol_id_t = 201;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IFLIX: ndpi_protocol_id_t = 202;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GITHUB: ndpi_protocol_id_t = 203;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BJNP: ndpi_protocol_id_t = 204;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_REDDIT: ndpi_protocol_id_t = 205;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WIREGUARD: ndpi_protocol_id_t = 206;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SMPP: ndpi_protocol_id_t = 207;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DNSCRYPT: ndpi_protocol_id_t = 208;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TINC: ndpi_protocol_id_t = 209;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DEEZER: ndpi_protocol_id_t = 210;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_INSTAGRAM: ndpi_protocol_id_t = 211;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MICROSOFT: ndpi_protocol_id_t = 212;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BLIZZARD: ndpi_protocol_id_t = 213;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TEREDO: ndpi_protocol_id_t = 214;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HOTSPOT_SHIELD: ndpi_protocol_id_t = 215;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IMO: ndpi_protocol_id_t = 216;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_DRIVE: ndpi_protocol_id_t = 217;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OCS: ndpi_protocol_id_t = 218;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MICROSOFT_365: ndpi_protocol_id_t = 219;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CLOUDFLARE: ndpi_protocol_id_t = 220;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MS_ONE_DRIVE: ndpi_protocol_id_t = 221;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MQTT: ndpi_protocol_id_t = 222;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RX: ndpi_protocol_id_t = 223;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLESTORE: ndpi_protocol_id_t = 224;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPENDNS: ndpi_protocol_id_t = 225;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GIT: ndpi_protocol_id_t = 226;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DRDA: ndpi_protocol_id_t = 227;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PLAYSTORE: ndpi_protocol_id_t = 228;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOMEIP: ndpi_protocol_id_t = 229;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FIX: ndpi_protocol_id_t = 230;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PLAYSTATION: ndpi_protocol_id_t = 231;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PASTEBIN: ndpi_protocol_id_t = 232;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LINKEDIN: ndpi_protocol_id_t = 233;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOUNDCLOUD: ndpi_protocol_id_t = 234;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VALVE_SDR: ndpi_protocol_id_t = 235;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LISP: ndpi_protocol_id_t = 236;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DIAMETER: ndpi_protocol_id_t = 237;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE_PUSH: ndpi_protocol_id_t = 238;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_SERVICES: ndpi_protocol_id_t = 239;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMAZON_VIDEO: ndpi_protocol_id_t = 240;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_DOCS: ndpi_protocol_id_t = 241;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WHATSAPP_FILES: ndpi_protocol_id_t = 242;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TARGUS_GETDATA: ndpi_protocol_id_t = 243;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DNP3: ndpi_protocol_id_t = 244;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IEC60870: ndpi_protocol_id_t = 245;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BLOOMBERG: ndpi_protocol_id_t = 246;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CAPWAP: ndpi_protocol_id_t = 247;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZABBIX: ndpi_protocol_id_t = 248;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_S7COMM: ndpi_protocol_id_t = 249;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MSTEAMS: ndpi_protocol_id_t = 250;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WEBSOCKET: ndpi_protocol_id_t = 251;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ANYDESK: ndpi_protocol_id_t = 252;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOAP: ndpi_protocol_id_t = 253;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE_SIRI: ndpi_protocol_id_t = 254;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SNAPCHAT_CALL: ndpi_protocol_id_t = 255;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HPVIRTGRP: ndpi_protocol_id_t = 256;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GENSHIN_IMPACT: ndpi_protocol_id_t = 257;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ACTIVISION: ndpi_protocol_id_t = 258;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FORTICLIENT: ndpi_protocol_id_t = 259;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_Z3950: ndpi_protocol_id_t = 260;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LIKEE: ndpi_protocol_id_t = 261;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GITLAB: ndpi_protocol_id_t = 262;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AVAST_SECUREDNS: ndpi_protocol_id_t = 263;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CASSANDRA: ndpi_protocol_id_t = 264;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMAZON_AWS: ndpi_protocol_id_t = 265;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SALESFORCE: ndpi_protocol_id_t = 266;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VIMEO: ndpi_protocol_id_t = 267;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FACEBOOK_VOIP: ndpi_protocol_id_t = 268;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SIGNAL_VOIP: ndpi_protocol_id_t = 269;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FUZE: ndpi_protocol_id_t = 270;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GTP_U: ndpi_protocol_id_t = 271;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GTP_C: ndpi_protocol_id_t = 272;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GTP_PRIME: ndpi_protocol_id_t = 273;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ALIBABA: ndpi_protocol_id_t = 274;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CRASHLYSTICS: ndpi_protocol_id_t = 275;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MICROSOFT_AZURE: ndpi_protocol_id_t = 276;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ICLOUD_PRIVATE_RELAY: ndpi_protocol_id_t = 277;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ETHERNET_IP: ndpi_protocol_id_t = 278;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BADOO: ndpi_protocol_id_t = 279;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ACCUWEATHER: ndpi_protocol_id_t = 280;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_CLASSROOM: ndpi_protocol_id_t = 281;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HSRP: ndpi_protocol_id_t = 282;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CYBERSECURITY: ndpi_protocol_id_t = 283;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_CLOUD: ndpi_protocol_id_t = 284;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TENCENT: ndpi_protocol_id_t = 285;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RAKNET: ndpi_protocol_id_t = 286;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_XIAOMI: ndpi_protocol_id_t = 287;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EDGECAST: ndpi_protocol_id_t = 288;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CACHEFLY: ndpi_protocol_id_t = 289;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOFTETHER: ndpi_protocol_id_t = 290;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MPEGDASH: ndpi_protocol_id_t = 291;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DAZN: ndpi_protocol_id_t = 292;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOTO: ndpi_protocol_id_t = 293;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RSH: ndpi_protocol_id_t = 294;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_1KXUN: ndpi_protocol_id_t = 295;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_PGM: ndpi_protocol_id_t = 296;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_PIM: ndpi_protocol_id_t = 297;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_COLLECTD: ndpi_protocol_id_t = 298;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TUNNELBEAR: ndpi_protocol_id_t = 299;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CLOUDFLARE_WARP: ndpi_protocol_id_t = 300;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_I3D: ndpi_protocol_id_t = 301;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RIOTGAMES: ndpi_protocol_id_t = 302;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PSIPHON: ndpi_protocol_id_t = 303;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ULTRASURF: ndpi_protocol_id_t = 304;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_THREEMA: ndpi_protocol_id_t = 305;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ALICLOUD: ndpi_protocol_id_t = 306;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AVAST: ndpi_protocol_id_t = 307;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TIVOCONNECT: ndpi_protocol_id_t = 308;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KISMET: ndpi_protocol_id_t = 309;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FASTCGI: ndpi_protocol_id_t = 310;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FTPS: ndpi_protocol_id_t = 311;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NATPMP: ndpi_protocol_id_t = 312;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SYNCTHING: ndpi_protocol_id_t = 313;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CRYNET: ndpi_protocol_id_t = 314;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LINE: ndpi_protocol_id_t = 315;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LINE_CALL: ndpi_protocol_id_t = 316;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLETVPLUS: ndpi_protocol_id_t = 317;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DIRECTV: ndpi_protocol_id_t = 318;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HBO: ndpi_protocol_id_t = 319;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VUDU: ndpi_protocol_id_t = 320;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SHOWTIME: ndpi_protocol_id_t = 321;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DAILYMOTION: ndpi_protocol_id_t = 322;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LIVESTREAM: ndpi_protocol_id_t = 323;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TENCENTVIDEO: ndpi_protocol_id_t = 324;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IHEARTRADIO: ndpi_protocol_id_t = 325;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TIDAL: ndpi_protocol_id_t = 326;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TUNEIN: ndpi_protocol_id_t = 327;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SIRIUSXMRADIO: ndpi_protocol_id_t = 328;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MUNIN: ndpi_protocol_id_t = 329;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ELASTICSEARCH: ndpi_protocol_id_t = 330;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TUYA_LP: ndpi_protocol_id_t = 331;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TPLINK_SHP: ndpi_protocol_id_t = 332;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOURCE_ENGINE: ndpi_protocol_id_t = 333;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BACNET: ndpi_protocol_id_t = 334;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OICQ: ndpi_protocol_id_t = 335;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HOTS: ndpi_protocol_id_t = 336;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FACEBOOK_REEL_STORY: ndpi_protocol_id_t = 337;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SRTP: ndpi_protocol_id_t = 338;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPERA_VPN: ndpi_protocol_id_t = 339;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EPICGAMES: ndpi_protocol_id_t = 340;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GEFORCENOW: ndpi_protocol_id_t = 341;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NVIDIA: ndpi_protocol_id_t = 342;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BITCOIN: ndpi_protocol_id_t = 343;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PROTONVPN: ndpi_protocol_id_t = 344;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APACHE_THRIFT: ndpi_protocol_id_t = 345;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ROBLOX: ndpi_protocol_id_t = 346;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SERVICE_LOCATION: ndpi_protocol_id_t = 347;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MULLVAD: ndpi_protocol_id_t = 348;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HTTP2: ndpi_protocol_id_t = 349;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HAPROXY: ndpi_protocol_id_t = 350;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RMCP: ndpi_protocol_id_t = 351;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CAN: ndpi_protocol_id_t = 352;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PROTOBUF: ndpi_protocol_id_t = 353;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ETHEREUM: ndpi_protocol_id_t = 354;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TELEGRAM_VOIP: ndpi_protocol_id_t = 355;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SINA_WEIBO: ndpi_protocol_id_t = 356;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TESLA_SERVICES: ndpi_protocol_id_t = 357;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PTPV2: ndpi_protocol_id_t = 358;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTPS: ndpi_protocol_id_t = 359;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPC_UA: ndpi_protocol_id_t = 360;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_S7COMM_PLUS: ndpi_protocol_id_t = 361;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FINS: ndpi_protocol_id_t = 362;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ETHERSIO: ndpi_protocol_id_t = 363;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_UMAS: ndpi_protocol_id_t = 364;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BECKHOFF_ADS: ndpi_protocol_id_t = 365;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ISO9506_1_MMS: ndpi_protocol_id_t = 366;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IEEE_C37118: ndpi_protocol_id_t = 367;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ETHERSBUS: ndpi_protocol_id_t = 368;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MONERO: ndpi_protocol_id_t = 369;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DCERPC: ndpi_protocol_id_t = 370;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PROFINET_IO: ndpi_protocol_id_t = 371;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HISLIP: ndpi_protocol_id_t = 372;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_UFTP: ndpi_protocol_id_t = 373;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPENFLOW: ndpi_protocol_id_t = 374;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_JSON_RPC: ndpi_protocol_id_t = 375;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WEBDAV: ndpi_protocol_id_t = 376;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APACHE_KAFKA: ndpi_protocol_id_t = 377;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NOMACHINE: ndpi_protocol_id_t = 378;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IEC62056: ndpi_protocol_id_t = 379;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HL7: ndpi_protocol_id_t = 380;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CEPH: ndpi_protocol_id_t = 381;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_CHAT: ndpi_protocol_id_t = 382;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ROUGHTIME: ndpi_protocol_id_t = 383;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PIA: ndpi_protocol_id_t = 384;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KCP: ndpi_protocol_id_t = 385;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DOTA2: ndpi_protocol_id_t = 386;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MUMBLE: ndpi_protocol_id_t = 387;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YOJIMBO: ndpi_protocol_id_t = 388;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ELECTRONICARTS: ndpi_protocol_id_t = 389;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_STOMP: ndpi_protocol_id_t = 390;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RADMIN: ndpi_protocol_id_t = 391;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RAFT: ndpi_protocol_id_t = 392;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CIP: ndpi_protocol_id_t = 393;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GEARMAN: ndpi_protocol_id_t = 394;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TENCENTGAMES: ndpi_protocol_id_t = 395;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GAIJIN: ndpi_protocol_id_t = 396;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_C1222: ndpi_protocol_id_t = 397;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HUAWEI: ndpi_protocol_id_t = 398;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HUAWEI_CLOUD: ndpi_protocol_id_t = 399;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DLEP: ndpi_protocol_id_t = 400;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BFD: ndpi_protocol_id_t = 401;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NETEASE_GAMES: ndpi_protocol_id_t = 402;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PATHOFEXILE: ndpi_protocol_id_t = 403;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_CALL: ndpi_protocol_id_t = 404;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PFCP: ndpi_protocol_id_t = 405;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FLUTE: ndpi_protocol_id_t = 406;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LOLWILDRIFT: ndpi_protocol_id_t = 407;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TESO: ndpi_protocol_id_t = 408;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LDP: ndpi_protocol_id_t = 409;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KNXNET_IP: ndpi_protocol_id_t = 410;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BLUESKY: ndpi_protocol_id_t = 411;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MASTODON: ndpi_protocol_id_t = 412;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_THREADS: ndpi_protocol_id_t = 413;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VIBER_VOIP: ndpi_protocol_id_t = 414;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZUG: ndpi_protocol_id_t = 415;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_JRMI: ndpi_protocol_id_t = 416;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RIPE_ATLAS: ndpi_protocol_id_t = 417;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HLS: ndpi_protocol_id_t = 418;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CLICKHOUSE: ndpi_protocol_id_t = 419;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NANO: ndpi_protocol_id_t = 420;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPENWIRE: ndpi_protocol_id_t = 421;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CNP_IP: ndpi_protocol_id_t = 422;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ATG: ndpi_protocol_id_t = 423;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TRDP: ndpi_protocol_id_t = 424;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LUSTRE: ndpi_protocol_id_t = 425;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NORDVPN: ndpi_protocol_id_t = 426;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SURFSHARK: ndpi_protocol_id_t = 427;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CACTUSVPN: ndpi_protocol_id_t = 428;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WINDSCRIBE: ndpi_protocol_id_t = 429;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SONOS: ndpi_protocol_id_t = 430;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DINGTALK: ndpi_protocol_id_t = 431;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PALTALK: ndpi_protocol_id_t = 432;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NAVER: ndpi_protocol_id_t = 433;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SHEIN: ndpi_protocol_id_t = 434;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TEMU: ndpi_protocol_id_t = 435;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TAOBAO: ndpi_protocol_id_t = 436;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MIKROTIK: ndpi_protocol_id_t = 437;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DICOM: ndpi_protocol_id_t = 438;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PARAMOUNTPLUS: ndpi_protocol_id_t = 439;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YANDEX_ALICE: ndpi_protocol_id_t = 440;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VIVOX: ndpi_protocol_id_t = 441;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DIGITALOCEAN: ndpi_protocol_id_t = 442;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RUTUBE: ndpi_protocol_id_t = 443;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LAGOFAST: ndpi_protocol_id_t = 444;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GEARUP_BOOSTER: ndpi_protocol_id_t = 445;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RUMBLE: ndpi_protocol_id_t = 446;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_UBIQUITY: ndpi_protocol_id_t = 447;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MSDO: ndpi_protocol_id_t = 448;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ROCKSTAR_GAMES: ndpi_protocol_id_t = 449;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KICK: ndpi_protocol_id_t = 450;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HAMACHI: ndpi_protocol_id_t = 451;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GLBP: ndpi_protocol_id_t = 452;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EASYWEATHER: ndpi_protocol_id_t = 453;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MUDFISH: ndpi_protocol_id_t = 454;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TRISTATION: ndpi_protocol_id_t = 455;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SAMSUNG_SDP: ndpi_protocol_id_t = 456;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MATTER: ndpi_protocol_id_t = 457;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AWS_COGNITO: ndpi_protocol_id_t = 458;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AWS_API_GATEWAY: ndpi_protocol_id_t = 459;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AWS_KINESIS: ndpi_protocol_id_t = 460;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AWS_EC2: ndpi_protocol_id_t = 461;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AWS_EMR: ndpi_protocol_id_t = 462;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AWS_S3: ndpi_protocol_id_t = 463;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AWS_CLOUDFRONT: ndpi_protocol_id_t = 464;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AWS_DYNAMODB: ndpi_protocol_id_t = 465;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ESPN: ndpi_protocol_id_t = 466;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AKAMAI: ndpi_protocol_id_t = 467;
pub type ndpi_protocol_id_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct patricia_uv16 {
    pub user_value: u_int16_t,
    pub additional_user_value: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct patricia_uv32 {
    pub user_value: u_int32_t,
    pub additional_user_value: u_int32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_patricia_node_value_t {
    pub u: ndpi_patricia_node_value_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_patricia_node_value_t__bindgen_ty_1 {
    pub uv16: [patricia_uv16; 2usize],
    pub uv32: patricia_uv32,
    pub uv64: u_int64_t,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ndpi_prefix_t {
    pub family: u_int16_t,
    pub bitlen: u_int16_t,
    pub ref_count: ::std::os::raw::c_int,
    pub add: _ndpi_prefix_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ndpi_prefix_t__bindgen_ty_1 {
    pub sin: in_addr,
    pub sin6: in6_addr,
    pub mac: [u_int8_t; 6usize],
}
pub type ndpi_prefix_t = _ndpi_prefix_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ndpi_patricia_node_t {
    pub bit: u_int16_t,
    pub prefix: *mut ndpi_prefix_t,
    pub l: *mut _ndpi_patricia_node_t,
    pub r: *mut _ndpi_patricia_node_t,
    pub parent: *mut _ndpi_patricia_node_t,
    pub data: *mut ::std::os::raw::c_void,
    pub custom_user_data: *mut ::std::os::raw::c_void,
    pub value: ndpi_patricia_node_value_t,
}
pub type ndpi_patricia_node_t = _ndpi_patricia_node_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_patricia_tree_stats {
    pub n_search: u_int64_t,
    pub n_found: u_int64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ndpi_patricia_tree_t {
    pub head: *mut ndpi_patricia_node_t,
    pub maxbits: u_int16_t,
    pub num_active_node: ::std::os::raw::c_int,
    pub stats: ndpi_patricia_tree_stats,
}
pub type ndpi_patricia_tree_t = _ndpi_patricia_tree_t;
pub const ndpi_log_level_t_NDPI_LOG_ERROR: ndpi_log_level_t = 0;
pub const ndpi_log_level_t_NDPI_LOG_TRACE: ndpi_log_level_t = 1;
pub const ndpi_log_level_t_NDPI_LOG_DEBUG: ndpi_log_level_t = 2;
pub const ndpi_log_level_t_NDPI_LOG_DEBUG_EXTRA: ndpi_log_level_t = 3;
pub type ndpi_log_level_t = ::std::os::raw::c_uint;
pub const ndpi_multimedia_flow_type_ndpi_multimedia_unknown_flow: ndpi_multimedia_flow_type = 0;
pub const ndpi_multimedia_flow_type_ndpi_multimedia_audio_flow: ndpi_multimedia_flow_type = 1;
pub const ndpi_multimedia_flow_type_ndpi_multimedia_video_flow: ndpi_multimedia_flow_type = 2;
pub const ndpi_multimedia_flow_type_ndpi_multimedia_screen_sharing_flow: ndpi_multimedia_flow_type =
    4;
pub type ndpi_multimedia_flow_type = ::std::os::raw::c_uint;
pub const ndpi_l4_proto_info_ndpi_l4_proto_unknown: ndpi_l4_proto_info = 0;
pub const ndpi_l4_proto_info_ndpi_l4_proto_tcp_only: ndpi_l4_proto_info = 1;
pub const ndpi_l4_proto_info_ndpi_l4_proto_udp_only: ndpi_l4_proto_info = 2;
pub const ndpi_l4_proto_info_ndpi_l4_proto_tcp_and_udp: ndpi_l4_proto_info = 3;
pub type ndpi_l4_proto_info = ::std::os::raw::c_uint;
pub const ndpi_packet_tunnel_ndpi_no_tunnel: ndpi_packet_tunnel = 0;
pub const ndpi_packet_tunnel_ndpi_gtp_tunnel: ndpi_packet_tunnel = 1;
pub const ndpi_packet_tunnel_ndpi_capwap_tunnel: ndpi_packet_tunnel = 2;
pub const ndpi_packet_tunnel_ndpi_tzsp_tunnel: ndpi_packet_tunnel = 3;
pub const ndpi_packet_tunnel_ndpi_l2tp_tunnel: ndpi_packet_tunnel = 4;
pub const ndpi_packet_tunnel_ndpi_vxlan_tunnel: ndpi_packet_tunnel = 5;
pub const ndpi_packet_tunnel_ndpi_gre_tunnel: ndpi_packet_tunnel = 6;
pub type ndpi_packet_tunnel = ::std::os::raw::c_uint;
pub const ndpi_risk_enum_NDPI_NO_RISK: ndpi_risk_enum = 0;
pub const ndpi_risk_enum_NDPI_URL_POSSIBLE_XSS: ndpi_risk_enum = 1;
pub const ndpi_risk_enum_NDPI_URL_POSSIBLE_SQL_INJECTION: ndpi_risk_enum = 2;
pub const ndpi_risk_enum_NDPI_URL_POSSIBLE_RCE_INJECTION: ndpi_risk_enum = 3;
pub const ndpi_risk_enum_NDPI_BINARY_APPLICATION_TRANSFER: ndpi_risk_enum = 4;
pub const ndpi_risk_enum_NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT: ndpi_risk_enum = 5;
pub const ndpi_risk_enum_NDPI_TLS_SELFSIGNED_CERTIFICATE: ndpi_risk_enum = 6;
pub const ndpi_risk_enum_NDPI_TLS_OBSOLETE_VERSION: ndpi_risk_enum = 7;
pub const ndpi_risk_enum_NDPI_TLS_WEAK_CIPHER: ndpi_risk_enum = 8;
pub const ndpi_risk_enum_NDPI_TLS_CERTIFICATE_EXPIRED: ndpi_risk_enum = 9;
pub const ndpi_risk_enum_NDPI_TLS_CERTIFICATE_MISMATCH: ndpi_risk_enum = 10;
pub const ndpi_risk_enum_NDPI_HTTP_SUSPICIOUS_USER_AGENT: ndpi_risk_enum = 11;
pub const ndpi_risk_enum_NDPI_NUMERIC_IP_HOST: ndpi_risk_enum = 12;
pub const ndpi_risk_enum_NDPI_HTTP_SUSPICIOUS_URL: ndpi_risk_enum = 13;
pub const ndpi_risk_enum_NDPI_HTTP_SUSPICIOUS_HEADER: ndpi_risk_enum = 14;
pub const ndpi_risk_enum_NDPI_TLS_NOT_CARRYING_HTTPS: ndpi_risk_enum = 15;
pub const ndpi_risk_enum_NDPI_SUSPICIOUS_DGA_DOMAIN: ndpi_risk_enum = 16;
pub const ndpi_risk_enum_NDPI_MALFORMED_PACKET: ndpi_risk_enum = 17;
pub const ndpi_risk_enum_NDPI_SSH_OBSOLETE_CLIENT_VERSION_OR_CIPHER: ndpi_risk_enum = 18;
pub const ndpi_risk_enum_NDPI_SSH_OBSOLETE_SERVER_VERSION_OR_CIPHER: ndpi_risk_enum = 19;
pub const ndpi_risk_enum_NDPI_SMB_INSECURE_VERSION: ndpi_risk_enum = 20;
pub const ndpi_risk_enum_NDPI_MISMATCHING_PROTOCOL_WITH_IP: ndpi_risk_enum = 21;
pub const ndpi_risk_enum_NDPI_UNSAFE_PROTOCOL: ndpi_risk_enum = 22;
pub const ndpi_risk_enum_NDPI_DNS_SUSPICIOUS_TRAFFIC: ndpi_risk_enum = 23;
pub const ndpi_risk_enum_NDPI_TLS_MISSING_SNI: ndpi_risk_enum = 24;
pub const ndpi_risk_enum_NDPI_HTTP_SUSPICIOUS_CONTENT: ndpi_risk_enum = 25;
pub const ndpi_risk_enum_NDPI_RISKY_ASN: ndpi_risk_enum = 26;
pub const ndpi_risk_enum_NDPI_RISKY_DOMAIN: ndpi_risk_enum = 27;
pub const ndpi_risk_enum_NDPI_MALICIOUS_FINGERPRINT: ndpi_risk_enum = 28;
pub const ndpi_risk_enum_NDPI_MALICIOUS_SHA1_CERTIFICATE: ndpi_risk_enum = 29;
pub const ndpi_risk_enum_NDPI_DESKTOP_OR_FILE_SHARING_SESSION: ndpi_risk_enum = 30;
pub const ndpi_risk_enum_NDPI_TLS_UNCOMMON_ALPN: ndpi_risk_enum = 31;
pub const ndpi_risk_enum_NDPI_TLS_CERT_VALIDITY_TOO_LONG: ndpi_risk_enum = 32;
pub const ndpi_risk_enum_NDPI_TLS_SUSPICIOUS_EXTENSION: ndpi_risk_enum = 33;
pub const ndpi_risk_enum_NDPI_TLS_FATAL_ALERT: ndpi_risk_enum = 34;
pub const ndpi_risk_enum_NDPI_SUSPICIOUS_ENTROPY: ndpi_risk_enum = 35;
pub const ndpi_risk_enum_NDPI_CLEAR_TEXT_CREDENTIALS: ndpi_risk_enum = 36;
pub const ndpi_risk_enum_NDPI_DNS_LARGE_PACKET: ndpi_risk_enum = 37;
pub const ndpi_risk_enum_NDPI_DNS_FRAGMENTED: ndpi_risk_enum = 38;
pub const ndpi_risk_enum_NDPI_INVALID_CHARACTERS: ndpi_risk_enum = 39;
pub const ndpi_risk_enum_NDPI_POSSIBLE_EXPLOIT: ndpi_risk_enum = 40;
pub const ndpi_risk_enum_NDPI_TLS_CERTIFICATE_ABOUT_TO_EXPIRE: ndpi_risk_enum = 41;
pub const ndpi_risk_enum_NDPI_PUNYCODE_IDN: ndpi_risk_enum = 42;
pub const ndpi_risk_enum_NDPI_ERROR_CODE_DETECTED: ndpi_risk_enum = 43;
pub const ndpi_risk_enum_NDPI_HTTP_CRAWLER_BOT: ndpi_risk_enum = 44;
pub const ndpi_risk_enum_NDPI_ANONYMOUS_SUBSCRIBER: ndpi_risk_enum = 45;
pub const ndpi_risk_enum_NDPI_UNIDIRECTIONAL_TRAFFIC: ndpi_risk_enum = 46;
pub const ndpi_risk_enum_NDPI_HTTP_OBSOLETE_SERVER: ndpi_risk_enum = 47;
pub const ndpi_risk_enum_NDPI_PERIODIC_FLOW: ndpi_risk_enum = 48;
pub const ndpi_risk_enum_NDPI_MINOR_ISSUES: ndpi_risk_enum = 49;
pub const ndpi_risk_enum_NDPI_TCP_ISSUES: ndpi_risk_enum = 50;
pub const ndpi_risk_enum_NDPI_UNRESOLVED_HOSTNAME: ndpi_risk_enum = 51;
pub const ndpi_risk_enum_NDPI_TLS_ALPN_SNI_MISMATCH: ndpi_risk_enum = 52;
pub const ndpi_risk_enum_NDPI_MALWARE_HOST_CONTACTED: ndpi_risk_enum = 53;
pub const ndpi_risk_enum_NDPI_BINARY_DATA_TRANSFER: ndpi_risk_enum = 54;
pub const ndpi_risk_enum_NDPI_PROBING_ATTEMPT: ndpi_risk_enum = 55;
pub const ndpi_risk_enum_NDPI_OBFUSCATED_TRAFFIC: ndpi_risk_enum = 56;
pub const ndpi_risk_enum_NDPI_MAX_RISK: ndpi_risk_enum = 57;
pub type ndpi_risk_enum = ::std::os::raw::c_uint;
pub type ndpi_risk = u_int64_t;
pub const ndpi_risk_param_id_NDPI_PARAM_HOSTNAME: ndpi_risk_param_id = 0;
pub const ndpi_risk_param_id_NDPI_PARAM_ISSUER_DN: ndpi_risk_param_id = 1;
pub const ndpi_risk_param_id_NDPI_PARAM_HOST_IPV4: ndpi_risk_param_id = 2;
pub const ndpi_risk_param_id_NDPI_MAX_RISK_PARAM_ID: ndpi_risk_param_id = 3;
pub type ndpi_risk_param_id = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_risk_params {
    pub id: ndpi_risk_param_id,
    pub value: *mut ::std::os::raw::c_void,
}
pub const ndpi_risk_severity_NDPI_RISK_LOW: ndpi_risk_severity = 0;
pub const ndpi_risk_severity_NDPI_RISK_MEDIUM: ndpi_risk_severity = 1;
pub const ndpi_risk_severity_NDPI_RISK_HIGH: ndpi_risk_severity = 2;
pub const ndpi_risk_severity_NDPI_RISK_SEVERE: ndpi_risk_severity = 3;
pub const ndpi_risk_severity_NDPI_RISK_CRITICAL: ndpi_risk_severity = 4;
pub const ndpi_risk_severity_NDPI_RISK_EMERGENCY: ndpi_risk_severity = 5;
pub type ndpi_risk_severity = ::std::os::raw::c_uint;
pub const ndpi_risk_score_NDPI_SCORE_RISK_LOW: ndpi_risk_score = 10;
pub const ndpi_risk_score_NDPI_SCORE_RISK_MEDIUM: ndpi_risk_score = 50;
pub const ndpi_risk_score_NDPI_SCORE_RISK_HIGH: ndpi_risk_score = 100;
pub const ndpi_risk_score_NDPI_SCORE_RISK_SEVERE: ndpi_risk_score = 150;
pub const ndpi_risk_score_NDPI_SCORE_RISK_CRITICAL: ndpi_risk_score = 200;
pub const ndpi_risk_score_NDPI_SCORE_RISK_EMERGENCY: ndpi_risk_score = 250;
pub type ndpi_risk_score = ::std::os::raw::c_uint;
pub const risk_percentage_CLIENT_NO_RISK_PERCENTAGE: risk_percentage = 0;
pub const risk_percentage_CLIENT_LOW_RISK_PERCENTAGE: risk_percentage = 10;
pub const risk_percentage_CLIENT_FAIR_RISK_PERCENTAGE: risk_percentage = 50;
pub const risk_percentage_CLIENT_HIGH_RISK_PERCENTAGE: risk_percentage = 90;
pub const risk_percentage_CLIENT_FULL_RISK_PERCENTAGE: risk_percentage = 100;
pub type risk_percentage = ::std::os::raw::c_uint;
pub const ndpi_risk_accountability_NDPI_NO_ACCOUNTABILITY: ndpi_risk_accountability = 0;
pub const ndpi_risk_accountability_NDPI_CLIENT_ACCOUNTABLE: ndpi_risk_accountability = 1;
pub const ndpi_risk_accountability_NDPI_SERVER_ACCOUNTABLE: ndpi_risk_accountability = 2;
pub const ndpi_risk_accountability_NDPI_BOTH_ACCOUNTABLE: ndpi_risk_accountability = 3;
pub type ndpi_risk_accountability = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_risk_info {
    pub risk: ndpi_risk_enum,
    pub severity: ndpi_risk_severity,
    pub default_client_risk_pctg: risk_percentage,
    pub accountability: ndpi_risk_accountability,
}
pub const ndpi_VISIT_ndpi_preorder: ndpi_VISIT = 0;
pub const ndpi_VISIT_ndpi_postorder: ndpi_VISIT = 1;
pub const ndpi_VISIT_ndpi_endorder: ndpi_VISIT = 2;
pub const ndpi_VISIT_ndpi_leaf: ndpi_VISIT = 3;
pub type ndpi_VISIT = ::std::os::raw::c_uint;
pub const ndpi_cfg_error_NDPI_CFG_INVALID_CONTEXT: ndpi_cfg_error = -1;
pub const ndpi_cfg_error_NDPI_CFG_NOT_FOUND: ndpi_cfg_error = -2;
pub const ndpi_cfg_error_NDPI_CFG_INVALID_PARAM: ndpi_cfg_error = -3;
pub const ndpi_cfg_error_NDPI_CFG_CONTEXT_ALREADY_INITIALIZED: ndpi_cfg_error = -4;
pub const ndpi_cfg_error_NDPI_CFG_CALLBACK_ERROR: ndpi_cfg_error = -5;
pub const ndpi_cfg_error_NDPI_CFG_OK: ndpi_cfg_error = 0;
pub type ndpi_cfg_error = ::std::os::raw::c_int;
pub type ndpi_ndpi_mask = u_int32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_bitmask {
    pub max_bits: u_int16_t,
    pub num_fds: u_int16_t,
    pub fds: *mut ndpi_ndpi_mask,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_dissector_bitmask {
    pub fds: [ndpi_ndpi_mask; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_detection_module_struct {
    _unused: [u8; 0],
}
pub type ndpi_debug_function_ptr = ::std::option::Option<
    unsafe extern "C" fn(
        protocol: u_int16_t,
        module_struct: *mut ndpi_detection_module_struct,
        log_level: ndpi_log_level_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
        format: *const ::std::os::raw::c_char,
        ...
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_chdlc {
    pub addr: u_int8_t,
    pub ctrl: u_int8_t,
    pub proto_code: u_int16_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_slarp {
    pub slarp_type: u_int32_t,
    pub addr_1: u_int32_t,
    pub addr_2: u_int32_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_cdp {
    pub version: u_int8_t,
    pub ttl: u_int8_t,
    pub checksum: u_int16_t,
    pub type_: u_int16_t,
    pub length: u_int16_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ethhdr {
    pub h_dest: [u_char; 6usize],
    pub h_source: [u_char; 6usize],
    pub h_proto: u_int16_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_arphdr {
    pub ar_hrd: u_int16_t,
    pub ar_pro: u_int16_t,
    pub ar_hln: u_int8_t,
    pub ar_pln: u_int8_t,
    pub ar_op: u_int16_t,
    pub arp_sha: [u_char; 6usize],
    pub arp_spa: u_int32_t,
    pub arp_tha: [u_char; 6usize],
    pub arp_tpa: u_int32_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_dhcphdr {
    pub msgType: u_int8_t,
    pub htype: u_int8_t,
    pub hlen: u_int8_t,
    pub hops: u_int8_t,
    pub xid: u_int32_t,
    pub secs: u_int16_t,
    pub flags: u_int16_t,
    pub ciaddr: u_int32_t,
    pub yiaddr: u_int32_t,
    pub siaddr: u_int32_t,
    pub giaddr: u_int32_t,
    pub chaddr: [u_int8_t; 16usize],
    pub sname: [u_int8_t; 64usize],
    pub file: [u_int8_t; 128usize],
    pub magic: u_int32_t,
    pub options: [u_int8_t; 308usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_mdns_rsp_entry {
    pub rsp_type: u_int16_t,
    pub rsp_class: u_int16_t,
    pub ttl: u_int32_t,
    pub data_len: u_int16_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_snap_extension {
    pub oui: u_int16_t,
    pub oui2: u_int8_t,
    pub proto_ID: u_int16_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_llc_header_snap {
    pub dsap: u_int8_t,
    pub ssap: u_int8_t,
    pub ctrl: u_int8_t,
    pub snap: ndpi_snap_extension,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_radiotap_header {
    pub version: u_int8_t,
    pub pad: u_int8_t,
    pub len: u_int16_t,
    pub present: u_int32_t,
    pub MAC_timestamp: u_int64_t,
    pub flags: u_int8_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_wifi_header {
    pub fc: u_int16_t,
    pub duration: u_int16_t,
    pub rcvr: [u_char; 6usize],
    pub trsm: [u_char; 6usize],
    pub dest: [u_char; 6usize],
    pub seq_ctrl: u_int16_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_mpls_header {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ndpi_mpls_header {
    #[inline]
    pub fn ttl(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ttl(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ttl_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ttl_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn s(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn s_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_s_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn exp(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_exp(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn exp_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_exp_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn label(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_label(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn label_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_label_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ttl: u_int32_t,
        s: u_int32_t,
        exp: u_int32_t,
        label: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ttl: u32 = unsafe { ::std::mem::transmute(ttl) };
            ttl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let s: u32 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let exp: u32 = unsafe { ::std::mem::transmute(exp) };
            exp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let label: u32 = unsafe { ::std::mem::transmute(label) };
            label as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_iphdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tos: u_int8_t,
    pub tot_len: u_int16_t,
    pub id: u_int16_t,
    pub frag_off: u_int16_t,
    pub ttl: u_int8_t,
    pub protocol: u_int8_t,
    pub check: u_int16_t,
    pub saddr: u_int32_t,
    pub daddr: u_int32_t,
}
impl ndpi_iphdr {
    #[inline]
    pub fn ihl(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ihl_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ihl_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn version(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: u_int8_t, version: u_int8_t) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::std::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndpi_in6_addr {
    pub u6_addr: ndpi_in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_in6_addr__bindgen_ty_1 {
    pub u6_addr8: [u_int8_t; 16usize],
    pub u6_addr16: [u_int16_t; 8usize],
    pub u6_addr32: [u_int32_t; 4usize],
    pub u6_addr64: [u_int64_t; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ip6_hdrctl {
    pub ip6_un1_flow: u_int32_t,
    pub ip6_un1_plen: u_int16_t,
    pub ip6_un1_nxt: u_int8_t,
    pub ip6_un1_hlim: u_int8_t,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndpi_ipv6hdr {
    pub ip6_hdr: ndpi_ip6_hdrctl,
    pub ip6_src: ndpi_in6_addr,
    pub ip6_dst: ndpi_in6_addr,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_tcphdr {
    pub source: u_int16_t,
    pub dest: u_int16_t,
    pub seq: u_int32_t,
    pub ack_seq: u_int32_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: u_int16_t,
    pub check: u_int16_t,
    pub urg_ptr: u_int16_t,
}
impl ndpi_tcphdr {
    #[inline]
    pub fn res1(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res1_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res1_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn doff(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn doff_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_doff_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fin(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fin_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_fin_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn syn(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn syn_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_syn_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rst(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rst_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_rst_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn psh(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn psh_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_psh_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ack(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ack_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ack_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn urg(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn urg_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_urg_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ece(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ece(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ece_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ece_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cwr(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cwr(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cwr_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_cwr_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u_int16_t,
        doff: u_int16_t,
        fin: u_int16_t,
        syn: u_int16_t,
        rst: u_int16_t,
        psh: u_int16_t,
        ack: u_int16_t,
        urg: u_int16_t,
        ece: u_int16_t,
        cwr: u_int16_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::std::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::std::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::std::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::std::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::std::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::std::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::std::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ece: u16 = unsafe { ::std::mem::transmute(ece) };
            ece as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cwr: u16 = unsafe { ::std::mem::transmute(cwr) };
            cwr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_udphdr {
    pub source: u_int16_t,
    pub dest: u_int16_t,
    pub len: u_int16_t,
    pub check: u_int16_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_dns_packet_header {
    pub tr_id: u_int16_t,
    pub flags: u_int16_t,
    pub num_queries: u_int16_t,
    pub num_answers: u_int16_t,
    pub authority_rrs: u_int16_t,
    pub additional_rrs: u_int16_t,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndpi_icmphdr {
    pub type_: u_int8_t,
    pub code: u_int8_t,
    pub checksum: u_int16_t,
    pub un: ndpi_icmphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_icmphdr__bindgen_ty_1 {
    pub echo: ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1,
    pub gateway: u_int32_t,
    pub frag: ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1 {
    pub id: u_int16_t,
    pub sequence: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2 {
    pub _unused: u_int16_t,
    pub mtu: u_int16_t,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndpi_icmp6hdr {
    pub icmp6_type: u_int8_t,
    pub icmp6_code: u_int8_t,
    pub icmp6_cksum: u_int16_t,
    pub icmp6_dataun: ndpi_icmp6hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_icmp6hdr__bindgen_ty_1 {
    pub icmp6_un_data32: [u_int32_t; 1usize],
    pub icmp6_un_data16: [u_int16_t; 2usize],
    pub icmp6_un_data8: [u_int8_t; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_vxlanhdr {
    pub flags: u_int16_t,
    pub groupPolicy: u_int16_t,
    pub vni: [u_int8_t; 3usize],
    pub reserved: u_int8_t,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_gre_basehdr {
    pub flags: u16,
    pub protocol: u16,
}
#[doc = " Optional information about flow management (per packet)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_input_info {
    pub in_pkt_dir: ::std::os::raw::c_uchar,
    pub seen_flow_beginning: ::std::os::raw::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_binary_bitmap_entry {
    pub value: u_int64_t,
    pub category: u_int8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_ip_addr_t {
    pub ipv4: u_int32_t,
    pub ipv6: ndpi_in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct message {
    pub buffer: *mut u_int8_t,
    pub buffer_len: u_int,
    pub buffer_used: u_int,
    pub next_seq: u_int32_t,
}
pub type message_t = message;
pub const ndpi_http_method_NDPI_HTTP_METHOD_UNKNOWN: ndpi_http_method = 0;
pub const ndpi_http_method_NDPI_HTTP_METHOD_OPTIONS: ndpi_http_method = 1;
pub const ndpi_http_method_NDPI_HTTP_METHOD_GET: ndpi_http_method = 2;
pub const ndpi_http_method_NDPI_HTTP_METHOD_HEAD: ndpi_http_method = 3;
pub const ndpi_http_method_NDPI_HTTP_METHOD_PATCH: ndpi_http_method = 4;
pub const ndpi_http_method_NDPI_HTTP_METHOD_POST: ndpi_http_method = 5;
pub const ndpi_http_method_NDPI_HTTP_METHOD_PUT: ndpi_http_method = 6;
pub const ndpi_http_method_NDPI_HTTP_METHOD_DELETE: ndpi_http_method = 7;
pub const ndpi_http_method_NDPI_HTTP_METHOD_TRACE: ndpi_http_method = 8;
pub const ndpi_http_method_NDPI_HTTP_METHOD_CONNECT: ndpi_http_method = 9;
pub const ndpi_http_method_NDPI_HTTP_METHOD_RPC_CONNECT: ndpi_http_method = 10;
pub const ndpi_http_method_NDPI_HTTP_METHOD_RPC_IN_DATA: ndpi_http_method = 11;
pub const ndpi_http_method_NDPI_HTTP_METHOD_RPC_OUT_DATA: ndpi_http_method = 12;
pub const ndpi_http_method_NDPI_HTTP_METHOD_MKCOL: ndpi_http_method = 13;
pub const ndpi_http_method_NDPI_HTTP_METHOD_MOVE: ndpi_http_method = 14;
pub const ndpi_http_method_NDPI_HTTP_METHOD_COPY: ndpi_http_method = 15;
pub const ndpi_http_method_NDPI_HTTP_METHOD_LOCK: ndpi_http_method = 16;
pub const ndpi_http_method_NDPI_HTTP_METHOD_UNLOCK: ndpi_http_method = 17;
pub const ndpi_http_method_NDPI_HTTP_METHOD_PROPFIND: ndpi_http_method = 18;
pub const ndpi_http_method_NDPI_HTTP_METHOD_PROPPATCH: ndpi_http_method = 19;
pub type ndpi_http_method = ::std::os::raw::c_uint;
pub const ptree_type_NDPI_PTREE_RISK_MASK: ptree_type = 0;
pub const ptree_type_NDPI_PTREE_RISK_MASK6: ptree_type = 1;
pub const ptree_type_NDPI_PTREE_RISK: ptree_type = 2;
pub const ptree_type_NDPI_PTREE_RISK6: ptree_type = 3;
pub const ptree_type_NDPI_PTREE_PROTOCOLS: ptree_type = 4;
pub const ptree_type_NDPI_PTREE_PROTOCOLS6: ptree_type = 5;
pub const ptree_type_NDPI_PTREE_MAX: ptree_type = 6;
pub type ptree_type = ::std::os::raw::c_uint;
pub const automa_type_NDPI_AUTOMA_HOST: automa_type = 0;
pub const automa_type_NDPI_AUTOMA_DOMAIN: automa_type = 1;
pub const automa_type_NDPI_AUTOMA_TLS_CERT: automa_type = 2;
pub const automa_type_NDPI_AUTOMA_RISK_MASK: automa_type = 3;
pub const automa_type_NDPI_AUTOMA_COMMON_ALPNS: automa_type = 4;
pub const automa_type_NDPI_AUTOMA_MAX: automa_type = 5;
pub type automa_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_automa_stats {
    pub n_search: u_int64_t,
    pub n_found: u_int64_t,
}
pub const str_hash_type_NDPI_STR_HASH_MALICIOUS_JA4: str_hash_type = 0;
pub const str_hash_type_NDPI_STR_HASH_MALICIOUS_SHA1: str_hash_type = 1;
pub const str_hash_type_NDPI_STR_HASH_TCP_FINGERPRINTS: str_hash_type = 2;
pub const str_hash_type_NDPI_STR_HASH_PUBLIC_DOMAIN_SUFFIX: str_hash_type = 3;
pub const str_hash_type_NDPI_STR_HASH_JA4_CUSTOM_PROTOS: str_hash_type = 4;
pub const str_hash_type_NDPI_STR_HASH_FP_CUSTOM_PROTOS: str_hash_type = 5;
pub const str_hash_type_NDPI_STR_HASH_HTTP_URL: str_hash_type = 6;
pub const str_hash_type_NDPI_STR_HASH_MAX: str_hash_type = 7;
pub type str_hash_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_str_hash_stats {
    pub n_search: u_int64_t,
    pub n_found: u_int64_t,
}
pub const lru_cache_type_NDPI_LRUCACHE_OOKLA: lru_cache_type = 0;
pub const lru_cache_type_NDPI_LRUCACHE_BITTORRENT: lru_cache_type = 1;
pub const lru_cache_type_NDPI_LRUCACHE_STUN: lru_cache_type = 2;
pub const lru_cache_type_NDPI_LRUCACHE_TLS_CERT: lru_cache_type = 3;
pub const lru_cache_type_NDPI_LRUCACHE_MINING: lru_cache_type = 4;
pub const lru_cache_type_NDPI_LRUCACHE_MSTEAMS: lru_cache_type = 5;
pub const lru_cache_type_NDPI_LRUCACHE_FPC_DNS: lru_cache_type = 6;
pub const lru_cache_type_NDPI_LRUCACHE_SIGNAL: lru_cache_type = 7;
pub const lru_cache_type_NDPI_LRUCACHE_MAX: lru_cache_type = 8;
pub type lru_cache_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_lru_cache_entry {
    pub key: u_int64_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub timestamp: u_int32_t,
}
impl ndpi_lru_cache_entry {
    #[inline]
    pub fn is_full(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_full(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_full_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_full_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_value(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn value_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_value_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pad(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pad_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pad_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_full: u_int32_t,
        value: u_int32_t,
        pad: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_full: u32 = unsafe { ::std::mem::transmute(is_full) };
            is_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 16u8, {
            let value: u32 = unsafe { ::std::mem::transmute(value) };
            value as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let pad: u32 = unsafe { ::std::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_lru_cache_stats {
    pub n_insert: u_int64_t,
    pub n_search: u_int64_t,
    pub n_found: u_int64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_lru_cache {
    pub num_entries: u_int32_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub stats: ndpi_lru_cache_stats,
    pub entries: *mut ndpi_lru_cache_entry,
}
impl ndpi_lru_cache {
    #[inline]
    pub fn ttl(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ttl(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ttl_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ttl_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shared(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ttl: u_int32_t,
        shared: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let ttl: u32 = unsafe { ::std::mem::transmute(ttl) };
            ttl as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_tls_block {
    pub block_type: u_int8_t,
    pub len: i16,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_tcp_struct {
    pub next_tcp_seq_nr: [u_int32_t; 2usize],
    pub last_tcp_pkt_payload_len: u_int16_t,
    pub cli2srv_tcp_flags: u_int8_t,
    pub srv2cli_tcp_flags: u_int8_t,
    pub ftp_imap_pop_smtp: ndpi_flow_tcp_struct__bindgen_ty_1,
    pub tls: ndpi_flow_tcp_struct__bindgen_ty_2,
    pub smtp_command_bitmask: u_int16_t,
    pub pop_command_bitmask: u_int16_t,
    pub rtmp_client_buffer_len: u_int16_t,
    pub hcl_notes_packet_id: u_int8_t,
    pub wa_matched_so_far: u_int8_t,
    pub irc_stage: u_int8_t,
    pub nest_log_sink_matches: u_int8_t,
    pub memcached_matches: u_int8_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_tcp_struct__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub username: [::std::os::raw::c_char; 32usize],
    pub password: [::std::os::raw::c_char; 16usize],
}
impl ndpi_flow_tcp_struct__bindgen_ty_1 {
    #[inline]
    pub fn auth_found(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_found(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn auth_found_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_auth_found_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn auth_failed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_failed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn auth_failed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_auth_failed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn auth_tls(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn auth_tls_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_auth_tls_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn auth_done(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_done(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn auth_done_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_auth_done_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        auth_found: u_int8_t,
        auth_failed: u_int8_t,
        auth_tls: u_int8_t,
        auth_done: u_int8_t,
        _pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auth_found: u8 = unsafe { ::std::mem::transmute(auth_found) };
            auth_found as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let auth_failed: u8 = unsafe { ::std::mem::transmute(auth_failed) };
            auth_failed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let auth_tls: u8 = unsafe { ::std::mem::transmute(auth_tls) };
            auth_tls as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let auth_done: u8 = unsafe { ::std::mem::transmute(auth_done) };
            auth_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _pad: u8 = unsafe { ::std::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_tcp_struct__bindgen_ty_2 {
    pub app_data_seen: [u_int8_t; 2usize],
    pub num_tls_blocks: u_int8_t,
    pub num_processed_tls_blocks: u_int8_t,
    pub tls_blocks: [ndpi_tls_block; 8usize],
}
impl ndpi_flow_tcp_struct {
    #[inline]
    pub fn seen_syn(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_seen_syn(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn seen_syn_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_seen_syn_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn seen_syn_ack(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_seen_syn_ack(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn seen_syn_ack_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_seen_syn_ack_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn seen_ack(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_seen_ack(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn seen_ack_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_seen_ack_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irc_3a_counter(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_irc_3a_counter(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irc_3a_counter_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_irc_3a_counter_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn usenet_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_usenet_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn usenet_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_usenet_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn http_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_http_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn http_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_http_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn http_asymmetric_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_http_asymmetric_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn http_asymmetric_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_http_asymmetric_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gnutella_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_gnutella_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gnutella_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_gnutella_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ssh_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_ssh_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ssh_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ssh_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vnc_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_vnc_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vnc_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_vnc_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn radmin_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_radmin_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn radmin_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_radmin_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ftp_control_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_ftp_control_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ftp_control_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ftp_control_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn soap_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_soap_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn soap_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_soap_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn socks5_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_socks5_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn socks5_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_socks5_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn socks4_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_socks4_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn socks4_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_socks4_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn z3950_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_z3950_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn z3950_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_z3950_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rtmp_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_rtmp_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rtmp_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rtmp_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn postgres_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_postgres_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn postgres_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_postgres_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn icecast_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_icecast_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn icecast_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_icecast_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mail_pop_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_mail_pop_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mail_pop_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mail_pop_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mail_imap_stage(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_mail_imap_stage(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mail_imap_stage_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mail_imap_stage_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mail_imap_starttls(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mail_imap_starttls(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mail_imap_starttls_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mail_imap_starttls_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rdp_protocol_detected(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rdp_protocol_detected(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rdp_protocol_detected_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rdp_protocol_detected_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u_int64_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 20u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u_int64_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                20u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u_int64_t) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        seen_syn: u_int64_t,
        seen_syn_ack: u_int64_t,
        seen_ack: u_int64_t,
        irc_3a_counter: u_int64_t,
        usenet_stage: u_int64_t,
        http_stage: u_int64_t,
        http_asymmetric_stage: u_int64_t,
        gnutella_stage: u_int64_t,
        ssh_stage: u_int64_t,
        vnc_stage: u_int64_t,
        radmin_stage: u_int64_t,
        ftp_control_stage: u_int64_t,
        soap_stage: u_int64_t,
        socks5_stage: u_int64_t,
        socks4_stage: u_int64_t,
        z3950_stage: u_int64_t,
        rtmp_stage: u_int64_t,
        postgres_stage: u_int64_t,
        icecast_stage: u_int64_t,
        mail_pop_stage: u_int64_t,
        mail_imap_stage: u_int64_t,
        mail_imap_starttls: u_int64_t,
        rdp_protocol_detected: u_int64_t,
        reserved: u_int64_t,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let seen_syn: u64 = unsafe { ::std::mem::transmute(seen_syn) };
            seen_syn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let seen_syn_ack: u64 = unsafe { ::std::mem::transmute(seen_syn_ack) };
            seen_syn_ack as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let seen_ack: u64 = unsafe { ::std::mem::transmute(seen_ack) };
            seen_ack as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let irc_3a_counter: u64 = unsafe { ::std::mem::transmute(irc_3a_counter) };
            irc_3a_counter as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let usenet_stage: u64 = unsafe { ::std::mem::transmute(usenet_stage) };
            usenet_stage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let http_stage: u64 = unsafe { ::std::mem::transmute(http_stage) };
            http_stage as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let http_asymmetric_stage: u64 =
                unsafe { ::std::mem::transmute(http_asymmetric_stage) };
            http_asymmetric_stage as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let gnutella_stage: u64 = unsafe { ::std::mem::transmute(gnutella_stage) };
            gnutella_stage as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let ssh_stage: u64 = unsafe { ::std::mem::transmute(ssh_stage) };
            ssh_stage as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let vnc_stage: u64 = unsafe { ::std::mem::transmute(vnc_stage) };
            vnc_stage as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let radmin_stage: u64 = unsafe { ::std::mem::transmute(radmin_stage) };
            radmin_stage as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let ftp_control_stage: u64 = unsafe { ::std::mem::transmute(ftp_control_stage) };
            ftp_control_stage as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let soap_stage: u64 = unsafe { ::std::mem::transmute(soap_stage) };
            soap_stage as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let socks5_stage: u64 = unsafe { ::std::mem::transmute(socks5_stage) };
            socks5_stage as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let socks4_stage: u64 = unsafe { ::std::mem::transmute(socks4_stage) };
            socks4_stage as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let z3950_stage: u64 = unsafe { ::std::mem::transmute(z3950_stage) };
            z3950_stage as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let rtmp_stage: u64 = unsafe { ::std::mem::transmute(rtmp_stage) };
            rtmp_stage as u64
        });
        __bindgen_bitfield_unit.set(32usize, 3u8, {
            let postgres_stage: u64 = unsafe { ::std::mem::transmute(postgres_stage) };
            postgres_stage as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let icecast_stage: u64 = unsafe { ::std::mem::transmute(icecast_stage) };
            icecast_stage as u64
        });
        __bindgen_bitfield_unit.set(36usize, 2u8, {
            let mail_pop_stage: u64 = unsafe { ::std::mem::transmute(mail_pop_stage) };
            mail_pop_stage as u64
        });
        __bindgen_bitfield_unit.set(38usize, 3u8, {
            let mail_imap_stage: u64 = unsafe { ::std::mem::transmute(mail_imap_stage) };
            mail_imap_stage as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let mail_imap_starttls: u64 = unsafe { ::std::mem::transmute(mail_imap_starttls) };
            mail_imap_starttls as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let rdp_protocol_detected: u64 =
                unsafe { ::std::mem::transmute(rdp_protocol_detected) };
            rdp_protocol_detected as u64
        });
        __bindgen_bitfield_unit.set(43usize, 20u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_udp_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub epicgames_word: u_int32_t,
    pub rx_conn_epoch: u_int32_t,
    pub rx_conn_id: u_int32_t,
    pub wireguard_peer_index: [u_int32_t; 2usize],
    pub wireguard_stage: u_int8_t,
    pub memcached_matches: u_int8_t,
    pub eaq_pkt_id: u_int8_t,
    pub eaq_sequence: u_int32_t,
    pub mumble_ident: u_int64_t,
    pub hamachi_long: [u_int32_t; 2usize],
    pub hamachi_short: [u_int16_t; 2usize],
    pub quic_reasm_buf: *mut u_int8_t,
    pub quic_reasm_buf_bitmap: *mut u_int8_t,
    pub quic_reasm_buf_last_pos: u_int32_t,
    pub quic_server_cid: [u_int8_t; 8usize],
    pub quic_client_last_byte: u_int8_t,
    pub quic_orig_dest_conn_id: [u_int8_t; 20usize],
    pub quic_orig_dest_conn_id_len: u_int8_t,
    pub rdp_to_srv: [u_int8_t; 3usize],
    pub rdp_from_srv: [u_int8_t; 3usize],
    pub rdp_to_srv_pkts: u_int8_t,
    pub rdp_from_srv_pkts: u_int8_t,
    pub imo_last_one_byte_pkt: u_int8_t,
    pub imo_last_byte: u_int8_t,
    pub line_pkts: [u_int8_t; 2usize],
    pub line_base_cnt: [u_int8_t; 2usize],
    pub tftp_data_num: u_int16_t,
    pub tftp_ack_num: u_int16_t,
}
impl ndpi_flow_udp_struct {
    #[inline]
    pub fn tftp_stage(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tftp_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tftp_stage_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tftp_stage_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xbox_stage(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xbox_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xbox_stage_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_xbox_stage_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn quic_server_cid_stage(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_quic_server_cid_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn quic_server_cid_stage_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_quic_server_cid_stage_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn quic_0rtt_found(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quic_0rtt_found(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn quic_0rtt_found_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_quic_0rtt_found_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn quic_vn_pair(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quic_vn_pair(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn quic_vn_pair_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_quic_vn_pair_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lolwildrift_stage(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lolwildrift_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lolwildrift_stage_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lolwildrift_stage_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zoom_p2p(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zoom_p2p(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zoom_p2p_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_zoom_p2p_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn raknet_custom(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_raknet_custom(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn raknet_custom_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_raknet_custom_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mumble_stage(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mumble_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mumble_stage_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mumble_stage_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hamachi_stage(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hamachi_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hamachi_stage_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hamachi_stage_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn epicgames_stage(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_epicgames_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn epicgames_stage_raw(this: *const Self) -> u_int32_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_epicgames_stage_raw(this: *mut Self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tftp_stage: u_int32_t,
        xbox_stage: u_int32_t,
        quic_server_cid_stage: u_int32_t,
        quic_0rtt_found: u_int32_t,
        quic_vn_pair: u_int32_t,
        lolwildrift_stage: u_int32_t,
        zoom_p2p: u_int32_t,
        raknet_custom: u_int32_t,
        mumble_stage: u_int32_t,
        hamachi_stage: u_int32_t,
        epicgames_stage: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let tftp_stage: u32 = unsafe { ::std::mem::transmute(tftp_stage) };
            tftp_stage as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let xbox_stage: u32 = unsafe { ::std::mem::transmute(xbox_stage) };
            xbox_stage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let quic_server_cid_stage: u32 =
                unsafe { ::std::mem::transmute(quic_server_cid_stage) };
            quic_server_cid_stage as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let quic_0rtt_found: u32 = unsafe { ::std::mem::transmute(quic_0rtt_found) };
            quic_0rtt_found as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let quic_vn_pair: u32 = unsafe { ::std::mem::transmute(quic_vn_pair) };
            quic_vn_pair as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let lolwildrift_stage: u32 = unsafe { ::std::mem::transmute(lolwildrift_stage) };
            lolwildrift_stage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let zoom_p2p: u32 = unsafe { ::std::mem::transmute(zoom_p2p) };
            zoom_p2p as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let raknet_custom: u32 = unsafe { ::std::mem::transmute(raknet_custom) };
            raknet_custom as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let mumble_stage: u32 = unsafe { ::std::mem::transmute(mumble_stage) };
            mumble_stage as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let hamachi_stage: u32 = unsafe { ::std::mem::transmute(hamachi_stage) };
            hamachi_stage as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let epicgames_stage: u32 = unsafe { ::std::mem::transmute(epicgames_stage) };
            epicgames_stage as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_global_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_port_range {
    pub port_low: u_int16_t,
    pub port_high: u_int16_t,
    pub is_custom: u_int8_t,
}
pub const ndpi_confidence_t_NDPI_CONFIDENCE_UNKNOWN: ndpi_confidence_t = 0;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_MATCH_BY_PORT: ndpi_confidence_t = 1;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_NBPF: ndpi_confidence_t = 2;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_DPI_PARTIAL: ndpi_confidence_t = 3;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_DPI_PARTIAL_CACHE: ndpi_confidence_t = 4;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_DPI_CACHE: ndpi_confidence_t = 5;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_DPI: ndpi_confidence_t = 6;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_MATCH_BY_IP: ndpi_confidence_t = 7;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_DPI_AGGRESSIVE: ndpi_confidence_t = 8;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_CUSTOM_RULE: ndpi_confidence_t = 9;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_MAX: ndpi_confidence_t = 10;
pub type ndpi_confidence_t = ::std::os::raw::c_uint;
pub const ndpi_fpc_confidence_t_NDPI_FPC_CONFIDENCE_UNKNOWN: ndpi_fpc_confidence_t = 0;
pub const ndpi_fpc_confidence_t_NDPI_FPC_CONFIDENCE_IP: ndpi_fpc_confidence_t = 1;
pub const ndpi_fpc_confidence_t_NDPI_FPC_CONFIDENCE_DNS: ndpi_fpc_confidence_t = 2;
pub const ndpi_fpc_confidence_t_NDPI_FPC_CONFIDENCE_DPI: ndpi_fpc_confidence_t = 3;
pub const ndpi_fpc_confidence_t_NDPI_FPC_CONFIDENCE_CUSTOM_RULE: ndpi_fpc_confidence_t = 4;
pub const ndpi_fpc_confidence_t_NDPI_FPC_CONFIDENCE_MAX: ndpi_fpc_confidence_t = 5;
pub type ndpi_fpc_confidence_t = ::std::os::raw::c_uint;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_UNRATED: ndpi_protocol_breed_t = 0;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_SAFE: ndpi_protocol_breed_t = 1;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_ACCEPTABLE: ndpi_protocol_breed_t = 2;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_FUN: ndpi_protocol_breed_t = 3;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_UNSAFE: ndpi_protocol_breed_t = 4;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_POTENTIALLY_DANGEROUS: ndpi_protocol_breed_t = 5;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_DANGEROUS: ndpi_protocol_breed_t = 6;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_TRACKER_ADS: ndpi_protocol_breed_t = 7;
pub type ndpi_protocol_breed_t = ::std::os::raw::c_uint;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_UNSPECIFIED: ndpi_protocol_category_t = 0;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MEDIA: ndpi_protocol_category_t = 1;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VPN: ndpi_protocol_category_t = 2;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MAIL: ndpi_protocol_category_t = 3;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER: ndpi_protocol_category_t =
    4;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_WEB: ndpi_protocol_category_t = 5;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK: ndpi_protocol_category_t =
    6;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT: ndpi_protocol_category_t = 7;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_GAME: ndpi_protocol_category_t = 8;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CHAT: ndpi_protocol_category_t = 9;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VOIP: ndpi_protocol_category_t = 10;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_DATABASE: ndpi_protocol_category_t = 11;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS: ndpi_protocol_category_t =
    12;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CLOUD: ndpi_protocol_category_t = 13;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_NETWORK: ndpi_protocol_category_t = 14;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_COLLABORATIVE: ndpi_protocol_category_t =
    15;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_RPC: ndpi_protocol_category_t = 16;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_STREAMING: ndpi_protocol_category_t = 17;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SYSTEM_OS: ndpi_protocol_category_t = 18;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SW_UPDATE: ndpi_protocol_category_t = 19;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_1: ndpi_protocol_category_t = 20;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_2: ndpi_protocol_category_t = 21;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_3: ndpi_protocol_category_t = 22;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_4: ndpi_protocol_category_t = 23;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_5: ndpi_protocol_category_t = 24;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MUSIC: ndpi_protocol_category_t = 25;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VIDEO: ndpi_protocol_category_t = 26;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SHOPPING: ndpi_protocol_category_t = 27;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_PRODUCTIVITY: ndpi_protocol_category_t =
    28;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_FILE_SHARING: ndpi_protocol_category_t =
    29;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CONNECTIVITY_CHECK:
    ndpi_protocol_category_t = 30;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_IOT_SCADA: ndpi_protocol_category_t = 31;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VIRTUAL_ASSISTANT:
    ndpi_protocol_category_t = 32;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CYBERSECURITY: ndpi_protocol_category_t =
    33;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ADULT_CONTENT: ndpi_protocol_category_t =
    34;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MINING: ndpi_protocol_category_t = 99;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MALWARE: ndpi_protocol_category_t = 100;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ADVERTISEMENT: ndpi_protocol_category_t =
    101;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_BANNED_SITE: ndpi_protocol_category_t =
    102;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SITE_UNAVAILABLE:
    ndpi_protocol_category_t = 103;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ALLOWED_SITE: ndpi_protocol_category_t =
    104;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ANTIMALWARE: ndpi_protocol_category_t =
    105;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CRYPTO_BLOCKCHAIN:
    ndpi_protocol_category_t = 106;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_GAMBLING: ndpi_protocol_category_t = 107;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_HEALTH: ndpi_protocol_category_t = 108;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ARTIFICIAL_INTELLIGENCE:
    ndpi_protocol_category_t = 109;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_FINANCE: ndpi_protocol_category_t = 110;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_NEWS: ndpi_protocol_category_t = 111;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SPORT: ndpi_protocol_category_t = 112;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_BUSINESS: ndpi_protocol_category_t = 113;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_INTERNET_HOSTING:
    ndpi_protocol_category_t = 114;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_BLOCKCHAIN_CRYPTO:
    ndpi_protocol_category_t = 115;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_BLOG_FORUM: ndpi_protocol_category_t =
    116;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_GOVERNMENT: ndpi_protocol_category_t =
    117;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_EDU_CATION: ndpi_protocol_category_t =
    118;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CDN_PROXY: ndpi_protocol_category_t = 119;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_HARDWARE_SOFTWARE:
    ndpi_protocol_category_t = 120;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_DATING: ndpi_protocol_category_t = 121;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_TRAVEL: ndpi_protocol_category_t = 122;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_FOOD: ndpi_protocol_category_t = 123;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_BOTS: ndpi_protocol_category_t = 124;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SCANNERS: ndpi_protocol_category_t = 125;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_HOSTING: ndpi_protocol_category_t = 126;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ART: ndpi_protocol_category_t = 127;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_FASHION: ndpi_protocol_category_t = 128;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_BOOKS: ndpi_protocol_category_t = 129;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SCIENCE: ndpi_protocol_category_t = 130;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MAPS_NAVIGATION:
    ndpi_protocol_category_t = 131;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_LOGIN_PORTAL: ndpi_protocol_category_t =
    132;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_LEGAL: ndpi_protocol_category_t = 133;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ENVIRONMENTAL_SERVICES:
    ndpi_protocol_category_t = 134;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CULTURE: ndpi_protocol_category_t = 135;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_HOUSING: ndpi_protocol_category_t = 136;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_TELECOMMUNICATION:
    ndpi_protocol_category_t = 137;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_TRANSPORTATION: ndpi_protocol_category_t =
    138;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_DESIGN: ndpi_protocol_category_t = 139;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_EMPLOYMENT: ndpi_protocol_category_t =
    140;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_EVENTS: ndpi_protocol_category_t = 141;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_WEATHER: ndpi_protocol_category_t = 142;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_LIFESTYLE: ndpi_protocol_category_t = 143;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_REAL_ESTATE: ndpi_protocol_category_t =
    144;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SECURITY: ndpi_protocol_category_t = 145;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ENVIRONMENT: ndpi_protocol_category_t =
    146;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_HOBBY: ndpi_protocol_category_t = 147;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_COMPUTER_SCIENCE:
    ndpi_protocol_category_t = 148;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CONSTRUCTION: ndpi_protocol_category_t =
    149;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ENGINEERING: ndpi_protocol_category_t =
    150;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_RELIGION: ndpi_protocol_category_t = 151;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_ENTERTAINMENT: ndpi_protocol_category_t =
    152;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_AGRICULTURE: ndpi_protocol_category_t =
    153;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_TECHNOLOGY: ndpi_protocol_category_t =
    154;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_BEAUTY: ndpi_protocol_category_t = 155;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_HISTORY: ndpi_protocol_category_t = 156;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_POLITICS: ndpi_protocol_category_t = 157;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VEHICLES: ndpi_protocol_category_t = 158;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_NUM_CATEGORIES: ndpi_protocol_category_t = 159;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_ANY_CATEGORY: ndpi_protocol_category_t = 160;
pub type ndpi_protocol_category_t = ::std::os::raw::c_uint;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_UNSPECIFIED:
    ndpi_protocol_qoe_category_t = 0;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_VOIP_CALLS:
    ndpi_protocol_qoe_category_t = 1;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_VIDEO_CONFERENCING:
    ndpi_protocol_qoe_category_t = 2;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_ONLINE_GAMING:
    ndpi_protocol_qoe_category_t = 3;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_CLOUD_GAMING:
    ndpi_protocol_qoe_category_t = 4;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_WEB_BROWSING:
    ndpi_protocol_qoe_category_t = 5;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_DNS_QUERIES:
    ndpi_protocol_qoe_category_t = 6;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_LIVE_STREAMING:
    ndpi_protocol_qoe_category_t = 7;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_BUFFERED_STREAMING:
    ndpi_protocol_qoe_category_t = 8;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_REMOTE_ACCESS:
    ndpi_protocol_qoe_category_t = 9;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_HFT:
    ndpi_protocol_qoe_category_t = 10;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_IOT_OT:
    ndpi_protocol_qoe_category_t = 11;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_AV: ndpi_protocol_qoe_category_t =
    12;
pub const ndpi_protocol_qoe_category_t_NDPI_PROTOCOL_QOE_CATEGORY_MAX:
    ndpi_protocol_qoe_category_t = 13;
pub type ndpi_protocol_qoe_category_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_proto_defaults {
    pub protoName: [::std::os::raw::c_char; 32usize],
    pub protoCategory: ndpi_protocol_category_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub subprotocols: *mut u_int16_t,
    pub subprotocol_count: u_int32_t,
    pub protoId: u_int16_t,
    pub dissector_idx: u_int16_t,
    pub tcp_default_ports: [ndpi_port_range; 5usize],
    pub udp_default_ports: [ndpi_port_range; 5usize],
    pub protoBreed: ndpi_protocol_breed_t,
    pub qoeCategory: ndpi_protocol_qoe_category_t,
}
impl ndpi_proto_defaults {
    #[inline]
    pub fn isClearTextProto(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isClearTextProto(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isClearTextProto_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_isClearTextProto_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn isAppProtocol(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isAppProtocol(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isAppProtocol_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_isAppProtocol_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn isCustomProto(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isCustomProto(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isCustomProto_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_isCustomProto_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn performIPcheck(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_performIPcheck(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn performIPcheck_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_performIPcheck_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _notused(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _notused_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__notused_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isClearTextProto: u_int8_t,
        isAppProtocol: u_int8_t,
        isCustomProto: u_int8_t,
        performIPcheck: u_int8_t,
        _notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isClearTextProto: u8 = unsafe { ::std::mem::transmute(isClearTextProto) };
            isClearTextProto as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isAppProtocol: u8 = unsafe { ::std::mem::transmute(isAppProtocol) };
            isAppProtocol as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isCustomProto: u8 = unsafe { ::std::mem::transmute(isCustomProto) };
            isCustomProto as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let performIPcheck: u8 = unsafe { ::std::mem::transmute(performIPcheck) };
            performIPcheck as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _notused: u8 = unsafe { ::std::mem::transmute(_notused) };
            _notused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ndpi_proto_defaults_t = ndpi_proto_defaults;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ndpi_automa {
    pub ac_automa: *mut ::std::os::raw::c_void,
    pub stats: ndpi_automa_stats,
}
pub type ndpi_automa = _ndpi_automa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_str_hash {
    pub priv_: *mut ::std::os::raw::c_void,
    pub stats: ndpi_str_hash_stats,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_master_app_protocol {
    pub master_protocol: u_int16_t,
    pub app_protocol: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_fpc_info {
    pub proto: ndpi_master_app_protocol,
    pub confidence: ndpi_fpc_confidence_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_proto_stack {
    pub protos: [u_int16_t; 8usize],
    pub protos_num: u_int16_t,
}
pub const ndpi_classification_state_NDPI_STATE_INSPECTING: ndpi_classification_state = 0;
pub const ndpi_classification_state_NDPI_STATE_PARTIAL: ndpi_classification_state = 1;
pub const ndpi_classification_state_NDPI_STATE_MONITORING: ndpi_classification_state = 2;
pub const ndpi_classification_state_NDPI_STATE_CLASSIFIED: ndpi_classification_state = 3;
pub type ndpi_classification_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_proto {
    pub proto: ndpi_master_app_protocol,
    pub protocol_stack: ndpi_proto_stack,
    pub protocol_by_ip: u_int16_t,
    pub category: ndpi_protocol_category_t,
    pub breed: ndpi_protocol_breed_t,
    pub fpc: ndpi_fpc_info,
    pub custom_category_userdata: *mut ::std::os::raw::c_void,
    pub state: ndpi_classification_state,
}
pub type ndpi_protocol = ndpi_proto;
pub type ndpi_bitmap = ::std::os::raw::c_void;
pub type ndpi_bitmap64 = ::std::os::raw::c_void;
pub type ndpi_bitmap64_fuse = ::std::os::raw::c_void;
pub type ndpi_bitmap_iterator = ::std::os::raw::c_void;
pub type ndpi_filter = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_binary_bitmap {
    pub num_allocated_entries: u_int32_t,
    pub num_used_entries: u_int32_t,
    pub entries: *mut ndpi_binary_bitmap_entry,
    pub is_compressed: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_domain_classify {
    pub domains: *mut ndpi_str_hash,
}
pub const ndpi_cipher_weakness_ndpi_cipher_safe: ndpi_cipher_weakness = 0;
pub const ndpi_cipher_weakness_ndpi_cipher_weak: ndpi_cipher_weakness = 1;
pub const ndpi_cipher_weakness_ndpi_cipher_insecure: ndpi_cipher_weakness = 2;
pub type ndpi_cipher_weakness = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_address_port {
    pub address: ndpi_address_port__bindgen_ty_1,
    pub port: u_int16_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_address_port__bindgen_ty_1 {
    pub v4: u_int32_t,
    pub v6: [u_int8_t; 16usize],
}
impl ndpi_address_port {
    #[inline]
    pub fn is_ipv6(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_ipv6(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_ipv6_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_is_ipv6_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int16_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u_int16_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                15u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_ipv6: u_int16_t,
        _pad: u_int16_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_ipv6: u16 = unsafe { ::std::mem::transmute(is_ipv6) };
            is_ipv6 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let _pad: u16 = unsafe { ::std::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_heuristics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl tls_heuristics {
    #[inline]
    pub fn is_safari_tls(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_safari_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_safari_tls_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_safari_tls_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_firefox_tls(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_firefox_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_firefox_tls_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_firefox_tls_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_chrome_tls(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_chrome_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_chrome_tls_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_chrome_tls_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn notused(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn notused_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_notused_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_safari_tls: u_int8_t,
        is_firefox_tls: u_int8_t,
        is_chrome_tls: u_int8_t,
        notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_safari_tls: u8 = unsafe { ::std::mem::transmute(is_safari_tls) };
            is_safari_tls as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_firefox_tls: u8 = unsafe { ::std::mem::transmute(is_firefox_tls) };
            is_firefox_tls as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_chrome_tls: u8 = unsafe { ::std::mem::transmute(is_chrome_tls) };
            is_chrome_tls as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let notused: u8 = unsafe { ::std::mem::transmute(notused) };
            notused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_risk_information {
    pub id: ndpi_risk_enum,
    pub info: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_metadata_monitoring {
    pub protos: ndpi_metadata_monitoring__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_metadata_monitoring__bindgen_ty_1 {
    pub dtls_stun_rtp: ndpi_metadata_monitoring__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_metadata_monitoring__bindgen_ty_1__bindgen_ty_1 {
    pub mapped_address: ndpi_address_port,
    pub peer_address: ndpi_address_port,
    pub relayed_address: ndpi_address_port,
    pub response_origin: ndpi_address_port,
    pub other_address: ndpi_address_port,
}
pub const ndpi_os_ndpi_os_unknown: ndpi_os = 0;
pub const ndpi_os_ndpi_os_windows: ndpi_os = 1;
pub const ndpi_os_ndpi_os_macos: ndpi_os = 2;
pub const ndpi_os_ndpi_os_ios_ipad_os: ndpi_os = 3;
pub const ndpi_os_ndpi_os_android: ndpi_os = 4;
pub const ndpi_os_ndpi_os_linux: ndpi_os = 5;
pub const ndpi_os_ndpi_os_freebsd: ndpi_os = 6;
pub const ndpi_os_ndpi_os_MAX_OS: ndpi_os = 7;
pub type ndpi_os = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtp_info {
    pub payload_type: u_int8_t,
    pub payload_detected: bool,
    pub evs_subtype: u_int32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_flow_struct {
    pub detected_protocol_stack: [u_int16_t; 2usize],
    pub protocol_stack: ndpi_proto_stack,
    pub state: ndpi_classification_state,
    pub guessed_protocol_id: u_int16_t,
    pub guessed_protocol_id_by_ip: u_int16_t,
    pub fast_callback_protocol_id: u_int16_t,
    pub guessed_header_category: u_int16_t,
    pub l4_proto: u_int8_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub custom_category_userdata: *mut ::std::os::raw::c_void,
    pub num_dissector_calls: u_int16_t,
    pub confidence: ndpi_confidence_t,
    pub fpc: ndpi_fpc_info,
    pub c_address: ndpi_flow_struct__bindgen_ty_1,
    pub s_address: ndpi_flow_struct__bindgen_ty_1,
    pub c_port: u_int16_t,
    pub s_port: u_int16_t,
    pub max_extra_packets_to_check: u_int8_t,
    pub num_extra_packets_checked: u_int8_t,
    pub num_processed_pkts: u_int16_t,
    pub extra_packets_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ndpi_detection_module_struct,
            flow: *mut ndpi_flow_struct,
        ) -> ::std::os::raw::c_int,
    >,
    pub last_packet_time_ms: u_int64_t,
    pub category: ndpi_protocol_category_t,
    pub breed: ndpi_protocol_breed_t,
    pub packet_counter: u_int16_t,
    pub packet_direction_counter: [u_int16_t; 2usize],
    pub all_packets_counter: u_int16_t,
    pub packet_direction_complete_counter: [u_int16_t; 2usize],
    pub l4: ndpi_flow_struct__bindgen_ty_2,
    pub entropy: f32,
    pub host_server_name: [::std::os::raw::c_char; 80usize],
    pub initial_binary_bytes: [u_int8_t; 8usize],
    pub initial_binary_bytes_len: u_int8_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub risk_mask: ndpi_risk,
    pub risk: ndpi_risk,
    pub risk_shadow: ndpi_risk,
    pub risk_infos: [ndpi_risk_information; 8usize],
    pub num_risk_infos: u_int8_t,
    pub tcp: ndpi_flow_struct__bindgen_ty_3,
    pub ndpi: ndpi_flow_struct__bindgen_ty_4,
    pub http: ndpi_flow_struct__bindgen_ty_5,
    pub flow_multimedia_types: u_int8_t,
    pub kerberos_buf: ndpi_flow_struct__bindgen_ty_6,
    pub stun: ndpi_flow_struct__bindgen_ty_7,
    pub tls_quic: ndpi_flow_struct__bindgen_ty_8,
    pub rtp: [rtp_info; 2usize],
    pub protos: ndpi_flow_struct__bindgen_ty_9,
    pub monit: *mut ndpi_metadata_monitoring,
    pub excluded_dissectors_bitmask: ndpi_dissector_bitmask,
    pub bittorrent_stage: u_int8_t,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ovpn_session_id: [[u_int8_t; 8usize]; 2usize],
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ovpn_heur_opcode__num_msgs: u_int8_t,
    pub ovpn_heur_opcode__codes: [u_int8_t; 4usize],
    pub ovpn_heur_opcode__resets: [u_int8_t; 2usize],
    pub ovpn_heur_opcode__missing_bytes: [u_int16_t; 2usize],
    pub tinc_state: u_int8_t,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rtp_seq_set: [u_int8_t; 2usize],
    pub rtp_seq: [u_int16_t; 2usize],
    pub flow_payload_len: u_int16_t,
    pub flow_payload: *mut ::std::os::raw::c_char,
    pub priv_data: [u_int8_t; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_flow_struct__bindgen_ty_1 {
    pub v4: u_int32_t,
    pub v6: [u_int8_t; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_flow_struct__bindgen_ty_2 {
    pub tcp: ndpi_flow_tcp_struct,
    pub udp: ndpi_flow_udp_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_3 {
    pub fingerprint: *mut ::std::os::raw::c_char,
    pub fingerprint_raw: *mut ::std::os::raw::c_char,
    pub os_hint: ndpi_os,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_4 {
    pub fingerprint: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5 {
    pub method: ndpi_http_method,
    pub request_version: u_int8_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub response_status_code: u_int16_t,
    pub url: *mut ::std::os::raw::c_char,
    pub content_type: *mut ::std::os::raw::c_char,
    pub request_content_type: *mut ::std::os::raw::c_char,
    pub user_agent: *mut ::std::os::raw::c_char,
    pub server: *mut ::std::os::raw::c_char,
    pub referer: *mut ::std::os::raw::c_char,
    pub host: *mut ::std::os::raw::c_char,
    pub detected_os: *mut ::std::os::raw::c_char,
    pub nat_ip: *mut ::std::os::raw::c_char,
    pub filename: *mut ::std::os::raw::c_char,
    pub username: *mut ::std::os::raw::c_char,
    pub password: *mut ::std::os::raw::c_char,
}
impl ndpi_flow_struct__bindgen_ty_5 {
    #[inline]
    pub fn websocket(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_websocket(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn websocket_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_websocket_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn request_header_observed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_request_header_observed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn request_header_observed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_request_header_observed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn first_payload_after_header_observed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_first_payload_after_header_observed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn first_payload_after_header_observed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_first_payload_after_header_observed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_form(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_form(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_form_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_form_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        websocket: u_int8_t,
        request_header_observed: u_int8_t,
        first_payload_after_header_observed: u_int8_t,
        is_form: u_int8_t,
        _pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let websocket: u8 = unsafe { ::std::mem::transmute(websocket) };
            websocket as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let request_header_observed: u8 =
                unsafe { ::std::mem::transmute(request_header_observed) };
            request_header_observed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let first_payload_after_header_observed: u8 =
                unsafe { ::std::mem::transmute(first_payload_after_header_observed) };
            first_payload_after_header_observed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_form: u8 = unsafe { ::std::mem::transmute(is_form) };
            is_form as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _pad: u8 = unsafe { ::std::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_6 {
    pub pktbuf: *mut ::std::os::raw::c_char,
    pub pktbuf_maxlen: u_int16_t,
    pub pktbuf_currlen: u_int16_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_7 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mapped_address: ndpi_address_port,
    pub peer_address: ndpi_address_port,
    pub relayed_address: ndpi_address_port,
    pub response_origin: ndpi_address_port,
    pub other_address: ndpi_address_port,
    pub num_xor_relayed_addresses: u_int8_t,
    pub num_xor_mapped_addresses: u_int8_t,
    pub num_non_stun_pkt: u_int8_t,
    pub non_stun_pkt_len: [u_int8_t; 2usize],
    pub rtp_counters: [u_int16_t; 2usize],
    pub t_start: u_int32_t,
    pub t_end: u_int32_t,
}
impl ndpi_flow_struct__bindgen_ty_7 {
    #[inline]
    pub fn maybe_dtls(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_maybe_dtls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn maybe_dtls_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_maybe_dtls_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rtcp_seen(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rtcp_seen(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rtcp_seen_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rtcp_seen_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_turn(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_turn(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_turn_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_turn_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_client_controlling(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_client_controlling(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_client_controlling_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_client_controlling_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pad(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pad_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pad_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        maybe_dtls: u_int8_t,
        rtcp_seen: u_int8_t,
        is_turn: u_int8_t,
        is_client_controlling: u_int8_t,
        pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let maybe_dtls: u8 = unsafe { ::std::mem::transmute(maybe_dtls) };
            maybe_dtls as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rtcp_seen: u8 = unsafe { ::std::mem::transmute(rtcp_seen) };
            rtcp_seen as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_turn: u8 = unsafe { ::std::mem::transmute(is_turn) };
            is_turn as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_client_controlling: u8 = unsafe { ::std::mem::transmute(is_client_controlling) };
            is_client_controlling as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let pad: u8 = unsafe { ::std::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_8 {
    pub message: [message_t; 2usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub obfuscated_heur_state: *mut tls_obfuscated_heuristic_state,
}
impl ndpi_flow_struct__bindgen_ty_8 {
    #[inline]
    pub fn certificate_processed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_certificate_processed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn certificate_processed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_certificate_processed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn change_cipher_from_client(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_change_cipher_from_client(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn change_cipher_from_client_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_change_cipher_from_client_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn change_cipher_from_server(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_change_cipher_from_server(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn change_cipher_from_server_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_change_cipher_from_server_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn from_opportunistic_tls(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_opportunistic_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn from_opportunistic_tls_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_from_opportunistic_tls_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn from_rdp(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_rdp(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn from_rdp_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_from_rdp_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pad(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pad_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pad_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        certificate_processed: u_int8_t,
        change_cipher_from_client: u_int8_t,
        change_cipher_from_server: u_int8_t,
        from_opportunistic_tls: u_int8_t,
        from_rdp: u_int8_t,
        pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let certificate_processed: u8 = unsafe { ::std::mem::transmute(certificate_processed) };
            certificate_processed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let change_cipher_from_client: u8 =
                unsafe { ::std::mem::transmute(change_cipher_from_client) };
            change_cipher_from_client as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let change_cipher_from_server: u8 =
                unsafe { ::std::mem::transmute(change_cipher_from_server) };
            change_cipher_from_server as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let from_opportunistic_tls: u8 =
                unsafe { ::std::mem::transmute(from_opportunistic_tls) };
            from_opportunistic_tls as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let from_rdp: u8 = unsafe { ::std::mem::transmute(from_rdp) };
            from_rdp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let pad: u8 = unsafe { ::std::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_flow_struct__bindgen_ty_9 {
    pub dns: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_1,
    pub ntp: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_2,
    pub kerberos: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_3,
    pub softether: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_4,
    pub mining: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_5,
    pub tls_quic: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_6,
    pub ssh: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_7,
    pub tftp: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_8,
    pub telnet: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_9,
    pub rsh: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_10,
    pub collectd: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_11,
    pub discord: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_12,
    pub ubntac2: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_13,
    pub bittorrent: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_14,
    pub dhcp: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_15,
    pub snmp: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_16,
    pub tivoconnect: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_17,
    pub natpmp: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_18,
    pub thrift: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_19,
    pub slp: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_20,
    pub sip: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_21,
    pub mikrotik: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_22,
    pub ssdp: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_23,
    pub fast_cgi: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_24,
    pub bfcp: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_25,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_1 {
    pub num_queries: u_int8_t,
    pub num_answers: u_int8_t,
    pub reply_code: u_int8_t,
    pub num_rsp_addr: u_int8_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub transaction_id: u_int16_t,
    pub query_type: u_int16_t,
    pub query_class: u_int16_t,
    pub rsp_type: u_int16_t,
    pub edns0_udp_payload_size: u_int16_t,
    pub is_rsp_addr_ipv6: [u_int8_t; 4usize],
    pub rsp_addr: [ndpi_ip_addr_t; 4usize],
    pub rsp_addr_ttl: [u_int32_t; 4usize],
    pub geolocation_iata_code: [::std::os::raw::c_char; 4usize],
    pub ptr_domain_name: [::std::os::raw::c_char; 64usize],
}
impl ndpi_flow_struct__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn is_query(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_query(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_query_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_query_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pad(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pad_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pad_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_query: u_int8_t,
        pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_query: u8 = unsafe { ::std::mem::transmute(is_query) };
            is_query as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let pad: u8 = unsafe { ::std::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_2 {
    pub version: u_int8_t,
    pub mode: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_3 {
    pub hostname: [::std::os::raw::c_char; 48usize],
    pub domain: [::std::os::raw::c_char; 48usize],
    pub username: [::std::os::raw::c_char; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_4 {
    pub ip: [::std::os::raw::c_char; 16usize],
    pub port: [::std::os::raw::c_char; 6usize],
    pub hostname: [::std::os::raw::c_char; 48usize],
    pub fqdn: [::std::os::raw::c_char; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_5 {
    pub currency: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_6 {
    pub server_names: *mut ::std::os::raw::c_char,
    pub advertised_alpns: *mut ::std::os::raw::c_char,
    pub negotiated_alpn: *mut ::std::os::raw::c_char,
    pub tls_supported_versions: *mut ::std::os::raw::c_char,
    pub issuerDN: *mut ::std::os::raw::c_char,
    pub subjectDN: *mut ::std::os::raw::c_char,
    pub notBefore: u_int32_t,
    pub notAfter: u_int32_t,
    pub ja3_server: [::std::os::raw::c_char; 33usize],
    pub ja4_client: [::std::os::raw::c_char; 37usize],
    pub ja4_client_raw: *mut ::std::os::raw::c_char,
    pub server_cipher: u_int16_t,
    pub sha1_certificate_fingerprint: [u_int8_t; 20usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub browser_heuristics: tls_heuristics,
    pub ssl_version: u_int16_t,
    pub server_names_len: u_int16_t,
    pub encrypted_ch: ndpi_flow_struct__bindgen_ty_9__bindgen_ty_6__bindgen_ty_1,
    pub server_unsafe_cipher: ndpi_cipher_weakness,
    pub quic_version: u_int32_t,
    pub quic_idle_timeout_sec: u_int32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_6__bindgen_ty_1 {
    pub version: u_int16_t,
}
impl ndpi_flow_struct__bindgen_ty_9__bindgen_ty_6 {
    #[inline]
    pub fn client_hello_processed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_client_hello_processed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn client_hello_processed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_client_hello_processed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ch_direction(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ch_direction(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ch_direction_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ch_direction_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn subprotocol_detected(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_subprotocol_detected(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subprotocol_detected_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_subprotocol_detected_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn server_hello_processed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_server_hello_processed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn server_hello_processed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_server_hello_processed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fingerprint_set(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fingerprint_set(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fingerprint_set_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_fingerprint_set_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn webrtc(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_webrtc(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn webrtc_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_webrtc_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pq_key_share(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pq_key_share(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pq_key_share_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pq_key_share_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pq_supported_groups(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pq_supported_groups(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pq_supported_groups_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pq_supported_groups_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        client_hello_processed: u_int8_t,
        ch_direction: u_int8_t,
        subprotocol_detected: u_int8_t,
        server_hello_processed: u_int8_t,
        fingerprint_set: u_int8_t,
        webrtc: u_int8_t,
        pq_key_share: u_int8_t,
        pq_supported_groups: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let client_hello_processed: u8 =
                unsafe { ::std::mem::transmute(client_hello_processed) };
            client_hello_processed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ch_direction: u8 = unsafe { ::std::mem::transmute(ch_direction) };
            ch_direction as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let subprotocol_detected: u8 = unsafe { ::std::mem::transmute(subprotocol_detected) };
            subprotocol_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let server_hello_processed: u8 =
                unsafe { ::std::mem::transmute(server_hello_processed) };
            server_hello_processed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fingerprint_set: u8 = unsafe { ::std::mem::transmute(fingerprint_set) };
            fingerprint_set as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let webrtc: u8 = unsafe { ::std::mem::transmute(webrtc) };
            webrtc as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pq_key_share: u8 = unsafe { ::std::mem::transmute(pq_key_share) };
            pq_key_share as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pq_supported_groups: u8 = unsafe { ::std::mem::transmute(pq_supported_groups) };
            pq_supported_groups as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_7 {
    pub client_signature: [::std::os::raw::c_char; 48usize],
    pub server_signature: [::std::os::raw::c_char; 48usize],
    pub hassh_client: [::std::os::raw::c_char; 33usize],
    pub hassh_server: [::std::os::raw::c_char; 33usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_8 {
    pub filename: [::std::os::raw::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_9 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub character_id: u_int8_t,
    pub username: [::std::os::raw::c_char; 32usize],
    pub password: [::std::os::raw::c_char; 32usize],
}
impl ndpi_flow_struct__bindgen_ty_9__bindgen_ty_9 {
    #[inline]
    pub fn username_detected(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_username_detected(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn username_detected_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_username_detected_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn username_found(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_username_found(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn username_found_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_username_found_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn password_detected(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_password_detected(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn password_detected_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_password_detected_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn password_found(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_password_found(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn password_found_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_password_found_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        username_detected: u_int8_t,
        username_found: u_int8_t,
        password_detected: u_int8_t,
        password_found: u_int8_t,
        _pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let username_detected: u8 = unsafe { ::std::mem::transmute(username_detected) };
            username_detected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let username_found: u8 = unsafe { ::std::mem::transmute(username_found) };
            username_found as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let password_detected: u8 = unsafe { ::std::mem::transmute(password_detected) };
            password_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let password_found: u8 = unsafe { ::std::mem::transmute(password_found) };
            password_found as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _pad: u8 = unsafe { ::std::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_10 {
    pub client_username: [::std::os::raw::c_char; 32usize],
    pub server_username: [::std::os::raw::c_char; 32usize],
    pub command: [::std::os::raw::c_char; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_11 {
    pub client_username: [::std::os::raw::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_12 {
    pub client_ip: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_13 {
    pub version: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_14 {
    pub hash: [u_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_15 {
    pub options: [::std::os::raw::c_char; 48usize],
    pub fingerprint: [::std::os::raw::c_char; 48usize],
    pub class_ident: [::std::os::raw::c_char; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_16 {
    pub version: u_int8_t,
    pub primitive: u_int8_t,
    pub error_status: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_17 {
    pub identity_uuid: [::std::os::raw::c_char; 37usize],
    pub machine: [::std::os::raw::c_char; 48usize],
    pub platform: [::std::os::raw::c_char; 32usize],
    pub services: [::std::os::raw::c_char; 48usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_18 {
    pub result_code: u_int16_t,
    pub internal_port: u_int16_t,
    pub external_port: u_int16_t,
    pub external_address: ndpi_ip_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_19 {
    pub message_type: u_int8_t,
    pub method: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_20 {
    pub url_count: u_int8_t,
    pub url: [[::std::os::raw::c_char; 48usize]; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_21 {
    pub from: *mut ::std::os::raw::c_char,
    pub from_imsi: [::std::os::raw::c_char; 16usize],
    pub to: *mut ::std::os::raw::c_char,
    pub to_imsi: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_22 {
    pub mac_addr: [::std::os::raw::c_char; 6usize],
    pub identity: [::std::os::raw::c_char; 16usize],
    pub version: [::std::os::raw::c_char; 48usize],
    pub sw_id: [::std::os::raw::c_char; 16usize],
    pub board: [::std::os::raw::c_char; 32usize],
    pub iface_name: [::std::os::raw::c_char; 32usize],
    pub ipv4_addr: u_int32_t,
    pub uptime: u_int32_t,
    pub ipv6_addr: ndpi_in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_23 {
    pub method: *mut ::std::os::raw::c_char,
    pub bootid: *mut ::std::os::raw::c_char,
    pub usn: *mut ::std::os::raw::c_char,
    pub cache_controle: *mut ::std::os::raw::c_char,
    pub location: *mut ::std::os::raw::c_char,
    pub household_smart_speaker_audio: *mut ::std::os::raw::c_char,
    pub rincon_household: *mut ::std::os::raw::c_char,
    pub rincon_bootseq: *mut ::std::os::raw::c_char,
    pub rincon_wifimode: *mut ::std::os::raw::c_char,
    pub rincon_variant: *mut ::std::os::raw::c_char,
    pub sonos_securelocation: *mut ::std::os::raw::c_char,
    pub securelocation_upnp: *mut ::std::os::raw::c_char,
    pub location_smart_speaker_audio: *mut ::std::os::raw::c_char,
    pub nt: *mut ::std::os::raw::c_char,
    pub nts: *mut ::std::os::raw::c_char,
    pub server: *mut ::std::os::raw::c_char,
    pub man: *mut ::std::os::raw::c_char,
    pub mx: *mut ::std::os::raw::c_char,
    pub st: *mut ::std::os::raw::c_char,
    pub user_agent: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_24 {
    pub method: ndpi_http_method,
    pub user_agent: [::std::os::raw::c_char; 32usize],
    pub url: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_9__bindgen_ty_25 {
    pub conference_id: u_int32_t,
    pub user_id: u_int16_t,
}
impl ndpi_flow_struct {
    #[inline]
    pub fn protocol_id_already_guessed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_protocol_id_already_guessed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn protocol_id_already_guessed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_protocol_id_already_guessed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn init_finished(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_init_finished(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn init_finished_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_init_finished_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn client_packet_direction(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_client_packet_direction(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn client_packet_direction_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_client_packet_direction_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn packet_direction(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_packet_direction(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn packet_direction_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_packet_direction_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_ipv6(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_ipv6(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_ipv6_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_ipv6_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn first_pkt_fully_encrypted(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_first_pkt_fully_encrypted(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn first_pkt_fully_encrypted_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_first_pkt_fully_encrypted_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_entropy_check(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skip_entropy_check(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_entropy_check_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_skip_entropy_check_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn protocol_was_guessed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_protocol_was_guessed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn protocol_was_guessed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_protocol_was_guessed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn already_gaveup(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_already_gaveup(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn already_gaveup_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_already_gaveup_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        protocol_id_already_guessed: u_int8_t,
        init_finished: u_int8_t,
        client_packet_direction: u_int8_t,
        packet_direction: u_int8_t,
        is_ipv6: u_int8_t,
        first_pkt_fully_encrypted: u_int8_t,
        skip_entropy_check: u_int8_t,
        protocol_was_guessed: u_int8_t,
        already_gaveup: u_int8_t,
        _pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let protocol_id_already_guessed: u8 =
                unsafe { ::std::mem::transmute(protocol_id_already_guessed) };
            protocol_id_already_guessed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let init_finished: u8 = unsafe { ::std::mem::transmute(init_finished) };
            init_finished as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let client_packet_direction: u8 =
                unsafe { ::std::mem::transmute(client_packet_direction) };
            client_packet_direction as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let packet_direction: u8 = unsafe { ::std::mem::transmute(packet_direction) };
            packet_direction as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_ipv6: u8 = unsafe { ::std::mem::transmute(is_ipv6) };
            is_ipv6 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let first_pkt_fully_encrypted: u8 =
                unsafe { ::std::mem::transmute(first_pkt_fully_encrypted) };
            first_pkt_fully_encrypted as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let skip_entropy_check: u8 = unsafe { ::std::mem::transmute(skip_entropy_check) };
            skip_entropy_check as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let protocol_was_guessed: u8 = unsafe { ::std::mem::transmute(protocol_was_guessed) };
            protocol_was_guessed as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let already_gaveup: u8 = unsafe { ::std::mem::transmute(already_gaveup) };
            already_gaveup as u64
        });
        __bindgen_bitfield_unit.set(9usize, 6u8, {
            let _pad: u8 = unsafe { ::std::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn risk_checked(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_risk_checked(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn risk_checked_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_risk_checked_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ip_risk_mask_evaluated(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ip_risk_mask_evaluated(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ip_risk_mask_evaluated_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ip_risk_mask_evaluated_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn host_risk_mask_evaluated(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_host_risk_mask_evaluated(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn host_risk_mask_evaluated_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_host_risk_mask_evaluated_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tree_risk_checked(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tree_risk_checked(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tree_risk_checked_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tree_risk_checked_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _notused(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _notused_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__notused_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        risk_checked: u_int8_t,
        ip_risk_mask_evaluated: u_int8_t,
        host_risk_mask_evaluated: u_int8_t,
        tree_risk_checked: u_int8_t,
        _notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let risk_checked: u8 = unsafe { ::std::mem::transmute(risk_checked) };
            risk_checked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ip_risk_mask_evaluated: u8 =
                unsafe { ::std::mem::transmute(ip_risk_mask_evaluated) };
            ip_risk_mask_evaluated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let host_risk_mask_evaluated: u8 =
                unsafe { ::std::mem::transmute(host_risk_mask_evaluated) };
            host_risk_mask_evaluated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tree_risk_checked: u8 = unsafe { ::std::mem::transmute(tree_risk_checked) };
            tree_risk_checked as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _notused: u8 = unsafe { ::std::mem::transmute(_notused) };
            _notused as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn bt_check_performed(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bt_check_performed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bt_check_performed_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_bt_check_performed_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zattoo_stage(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_zattoo_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zattoo_stage_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                1usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_zattoo_stage_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ookla_stage(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ookla_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ookla_stage_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ookla_stage_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn teamviewer_stage(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_teamviewer_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn teamviewer_stage_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                5usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_teamviewer_stage_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        bt_check_performed: u_int8_t,
        zattoo_stage: u_int8_t,
        ookla_stage: u_int8_t,
        teamviewer_stage: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bt_check_performed: u8 = unsafe { ::std::mem::transmute(bt_check_performed) };
            bt_check_performed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let zattoo_stage: u8 = unsafe { ::std::mem::transmute(zattoo_stage) };
            zattoo_stage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ookla_stage: u8 = unsafe { ::std::mem::transmute(ookla_stage) };
            ookla_stage as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let teamviewer_stage: u8 = unsafe { ::std::mem::transmute(teamviewer_stage) };
            teamviewer_stage as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn ovpn_alg_standard_state(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ovpn_alg_standard_state(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ovpn_alg_standard_state_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ovpn_alg_standard_state_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ovpn_alg_heur_opcode_state(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ovpn_alg_heur_opcode_state(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ovpn_alg_heur_opcode_state_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ovpn_alg_heur_opcode_state_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ovpn_heur_opcode__codes_num(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ovpn_heur_opcode__codes_num(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ovpn_heur_opcode__codes_num_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ovpn_heur_opcode__codes_num_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        ovpn_alg_standard_state: u_int8_t,
        ovpn_alg_heur_opcode_state: u_int8_t,
        ovpn_heur_opcode__codes_num: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let ovpn_alg_standard_state: u8 =
                unsafe { ::std::mem::transmute(ovpn_alg_standard_state) };
            ovpn_alg_standard_state as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let ovpn_alg_heur_opcode_state: u8 =
                unsafe { ::std::mem::transmute(ovpn_alg_heur_opcode_state) };
            ovpn_alg_heur_opcode_state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ovpn_heur_opcode__codes_num: u8 =
                unsafe { ::std::mem::transmute(ovpn_heur_opcode__codes_num) };
            ovpn_heur_opcode__codes_num as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rtcp_stage(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rtcp_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rtcp_stage_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rtcp_stage_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rtp_stage(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rtp_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rtp_stage_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rtp_stage_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_5(
        rtcp_stage: u_int8_t,
        rtp_stage: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let rtcp_stage: u8 = unsafe { ::std::mem::transmute(rtcp_stage) };
            rtcp_stage as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let rtp_stage: u8 = unsafe { ::std::mem::transmute(rtp_stage) };
            rtp_stage as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_protocol_match {
    pub string_to_match: *mut ::std::os::raw::c_char,
    pub proto_name: *mut ::std::os::raw::c_char,
    pub protocol_id: u_int16_t,
    pub protocol_category: ndpi_protocol_category_t,
    pub protocol_breed: ndpi_protocol_breed_t,
    pub level: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_network {
    pub network: u_int32_t,
    pub cidr: u_int8_t,
    pub value: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_network6 {
    pub network: *mut ::std::os::raw::c_char,
    pub cidr: u_int8_t,
    pub value: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_protocol_match_result {
    pub protocol_id: u_int32_t,
    pub protocol_category: ndpi_protocol_category_t,
    pub protocol_breed: ndpi_protocol_breed_t,
}
pub const ndpi_serialization_format_ndpi_serialization_format_unknown: ndpi_serialization_format =
    0;
pub const ndpi_serialization_format_ndpi_serialization_format_tlv: ndpi_serialization_format = 1;
pub const ndpi_serialization_format_ndpi_serialization_format_json: ndpi_serialization_format = 2;
pub const ndpi_serialization_format_ndpi_serialization_format_csv: ndpi_serialization_format = 3;
pub const ndpi_serialization_format_ndpi_serialization_format_multiline_json:
    ndpi_serialization_format = 4;
pub const ndpi_serialization_format_ndpi_serialization_format_inner_json:
    ndpi_serialization_format = 5;
pub type ndpi_serialization_format = ::std::os::raw::c_uint;
pub const ndpi_serialization_type_ndpi_serialization_unknown: ndpi_serialization_type = 0;
pub const ndpi_serialization_type_ndpi_serialization_end_of_record: ndpi_serialization_type = 1;
pub const ndpi_serialization_type_ndpi_serialization_uint8: ndpi_serialization_type = 2;
pub const ndpi_serialization_type_ndpi_serialization_uint16: ndpi_serialization_type = 3;
pub const ndpi_serialization_type_ndpi_serialization_uint32: ndpi_serialization_type = 4;
pub const ndpi_serialization_type_ndpi_serialization_uint64: ndpi_serialization_type = 5;
pub const ndpi_serialization_type_ndpi_serialization_int8: ndpi_serialization_type = 6;
pub const ndpi_serialization_type_ndpi_serialization_int16: ndpi_serialization_type = 7;
pub const ndpi_serialization_type_ndpi_serialization_int32: ndpi_serialization_type = 8;
pub const ndpi_serialization_type_ndpi_serialization_int64: ndpi_serialization_type = 9;
pub const ndpi_serialization_type_ndpi_serialization_float: ndpi_serialization_type = 10;
pub const ndpi_serialization_type_ndpi_serialization_string: ndpi_serialization_type = 11;
pub const ndpi_serialization_type_ndpi_serialization_start_of_block: ndpi_serialization_type = 12;
pub const ndpi_serialization_type_ndpi_serialization_end_of_block: ndpi_serialization_type = 13;
pub const ndpi_serialization_type_ndpi_serialization_start_of_list: ndpi_serialization_type = 14;
pub const ndpi_serialization_type_ndpi_serialization_end_of_list: ndpi_serialization_type = 15;
pub const ndpi_serialization_type_ndpi_serialization_double: ndpi_serialization_type = 16;
pub type ndpi_serialization_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_private_serializer_buffer_status {
    pub size_used: u_int32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_private_serializer_status {
    pub flags: u_int32_t,
    pub buffer: ndpi_private_serializer_buffer_status,
    pub header: ndpi_private_serializer_buffer_status,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_private_serializer_buffer {
    pub initial_size: u_int32_t,
    pub size: u_int32_t,
    pub data: *mut u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_private_serializer {
    pub status: ndpi_private_serializer_status,
    pub buffer: ndpi_private_serializer_buffer,
    pub header: ndpi_private_serializer_buffer,
    pub fmt: ndpi_serialization_format,
    pub csv_separator: [::std::os::raw::c_char; 2usize],
    pub has_snapshot: u_int8_t,
    pub multiline_json_array: u_int8_t,
    pub inner_json: u_int8_t,
    pub snapshot: ndpi_private_serializer_status,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_serializer {
    pub c: [::std::os::raw::c_char; 72usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_string {
    pub str_: *mut ::std::os::raw::c_char,
    pub str_len: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_analyze_struct {
    pub values: *mut u_int64_t,
    pub min_val: u_int64_t,
    pub max_val: u_int64_t,
    pub sum_total: u_int64_t,
    pub jitter_total: u_int64_t,
    pub num_data_entries: u_int32_t,
    pub next_value_insert_index: u_int32_t,
    pub num_values_array_len: u_int16_t,
    pub stddev: ndpi_analyze_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_analyze_struct__bindgen_ty_1 {
    pub sum_square_total: u_int64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_rsi_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub num_values: u_int16_t,
    pub next_index: u_int16_t,
    pub gains: *mut u_int32_t,
    pub losses: *mut u_int32_t,
    pub last_value: u_int32_t,
    pub total_gains: u_int32_t,
    pub total_losses: u_int32_t,
}
impl ndpi_rsi_struct {
    #[inline]
    pub fn empty(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_empty(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn empty_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_empty_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsi_ready(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsi_ready(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsi_ready_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rsi_ready_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _notused(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set__notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _notused_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__notused_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        empty: u_int8_t,
        rsi_ready: u_int8_t,
        _notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let empty: u8 = unsafe { ::std::mem::transmute(empty) };
            empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rsi_ready: u8 = unsafe { ::std::mem::transmute(rsi_ready) };
            rsi_ready as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let _notused: u8 = unsafe { ::std::mem::transmute(_notused) };
            _notused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_jitter_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub num_values: u_int16_t,
    pub next_index: u_int16_t,
    pub observations: *mut f32,
    pub last_value: f32,
    pub jitter_total: f32,
}
impl ndpi_jitter_struct {
    #[inline]
    pub fn empty(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_empty(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn empty_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_empty_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn jitter_ready(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_jitter_ready(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn jitter_ready_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_jitter_ready_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _notused(&self) -> u_int8_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set__notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _notused_raw(this: *const Self) -> u_int8_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__notused_raw(this: *mut Self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        empty: u_int8_t,
        jitter_ready: u_int8_t,
        _notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let empty: u8 = unsafe { ::std::mem::transmute(empty) };
            empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let jitter_ready: u8 = unsafe { ::std::mem::transmute(jitter_ready) };
            jitter_ready as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let _notused: u8 = unsafe { ::std::mem::transmute(_notused) };
            _notused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ndpi_void_fn_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
pub type ndpi_void_fn2_t = ::std::option::Option<
    unsafe extern "C" fn(prefix: *mut ndpi_prefix_t, data: *mut ::std::os::raw::c_void),
>;
pub type ndpi_void_fn3_t = ::std::option::Option<
    unsafe extern "C" fn(
        node: *mut ndpi_patricia_node_t,
        data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ptree {
    pub v4: *mut ndpi_patricia_tree_t,
    pub v6: *mut ndpi_patricia_tree_t,
}
pub type ndpi_ptree_t = ndpi_ptree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_hll {
    pub bits: u_int8_t,
    pub size: usize,
    pub registers: *mut u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_cm_sketch {
    pub num_hashes: u_int16_t,
    pub num_hash_buckets: u_int32_t,
    pub tables: *mut u_int32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_popcount {
    pub pop_count: u_int64_t,
    pub tot_bytes_count: u_int64_t,
}
pub const ndpi_bin_family_ndpi_bin_family8: ndpi_bin_family = 0;
pub const ndpi_bin_family_ndpi_bin_family16: ndpi_bin_family = 1;
pub const ndpi_bin_family_ndpi_bin_family32: ndpi_bin_family = 2;
pub const ndpi_bin_family_ndpi_bin_family64: ndpi_bin_family = 3;
pub const ndpi_bin_family_kMaxValue: ndpi_bin_family = 3;
pub type ndpi_bin_family = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_bin {
    pub is_empty: u_int8_t,
    pub num_bins: u_int16_t,
    pub family: ndpi_bin_family,
    pub u: ndpi_bin__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_bin__bindgen_ty_1 {
    pub bins8: *mut u_int8_t,
    pub bins16: *mut u_int16_t,
    pub bins32: *mut u_int32_t,
    pub bins64: *mut u_int64_t,
}
pub type ndpi_kd_tree = ::std::os::raw::c_void;
pub type ndpi_kd_tree_result = ::std::os::raw::c_void;
pub type ndpi_btree = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_knn {
    pub distances: *mut *mut f64,
    pub indices: *mut *mut ::std::os::raw::c_int,
    pub n_samples: ::std::os::raw::c_int,
    pub n_neighbors: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_hw_struct {
    pub params: ndpi_hw_struct__bindgen_ty_1,
    pub prev_error: ndpi_hw_struct__bindgen_ty_2,
    pub num_values: u_int32_t,
    pub u: f64,
    pub v: f64,
    pub sum_square_error: f64,
    pub y: *mut u_int64_t,
    pub s: *mut f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_hw_struct__bindgen_ty_1 {
    pub use_hw_additive_seasonal: u_int8_t,
    pub alpha: f64,
    pub beta: f64,
    pub gamma: f64,
    pub ro: f64,
    pub num_season_periods: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_hw_struct__bindgen_ty_2 {
    pub sum_square_error: f64,
    pub num_values_rollup: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ses_struct {
    pub params: ndpi_ses_struct__bindgen_ty_1,
    pub prev_error: ndpi_ses_struct__bindgen_ty_2,
    pub num_values: u_int32_t,
    pub sum_square_error: f64,
    pub last_forecast: f64,
    pub last_value: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ses_struct__bindgen_ty_1 {
    pub alpha: f64,
    pub ro: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ses_struct__bindgen_ty_2 {
    pub sum_square_error: f64,
    pub num_values_rollup: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_des_struct {
    pub params: ndpi_des_struct__bindgen_ty_1,
    pub prev_error: ndpi_des_struct__bindgen_ty_2,
    pub num_values: u_int32_t,
    pub sum_square_error: f64,
    pub last_forecast: f64,
    pub last_trend: f64,
    pub last_value: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_des_struct__bindgen_ty_1 {
    pub alpha: f64,
    pub beta: f64,
    pub ro: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_des_struct__bindgen_ty_2 {
    pub sum_square_error: f64,
    pub num_values_rollup: u_int8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_address_cache_item {
    pub addr: ndpi_ip_addr_t,
    pub hostname: *mut ::std::os::raw::c_char,
    pub expire_epoch: u_int32_t,
    pub next: *mut ndpi_address_cache_item,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_address_cache {
    pub num_cached_addresses: u_int32_t,
    pub num_root_nodes: u_int32_t,
    pub num_entries: u_int32_t,
    pub max_num_entries: u_int32_t,
    pub address_cache_root: *mut *mut ndpi_address_cache_item,
}
pub type ndpi_custom_dga_predict_fctn = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const ::std::os::raw::c_char,
        domain_length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ranking_epoch_entry {
    pub item_unique_id: u_int32_t,
    pub value: u_int64_t,
}
pub type ndpi_ranking_change = ndpi_ranking_epoch_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ranking_epoch {
    pub epoch: u_int32_t,
    pub entries: *mut ndpi_ranking_epoch_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ranking_header {
    pub ranking_version: u_int8_t,
    pub epochs_memory_len: u_int32_t,
    pub max_num_entries: u_int16_t,
    pub num_epochs: u_int8_t,
    pub next_epoch_id: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ranking {
    pub header: ndpi_ranking_header,
    pub epochs: *mut ::std::os::raw::c_char,
    pub num_updates_without_ranking_changes: u_int32_t,
}
unsafe extern "C" {
    pub fn ndpi_tdelete(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn ndpi_tfind(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn ndpi_tsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn ndpi_twalk(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: ndpi_VISIT,
                arg3: ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_void,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ndpi_tdestroy(
        vrootp: *mut ::std::os::raw::c_void,
        freefct: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
unsafe extern "C" {
    pub fn ndpi_bytestream_to_number(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_bytestream_to_number64(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_bytestream_dec_or_hex_to_number64(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_bytestream_to_ipv4(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_set_proto_subprotocols(
        ndpi_mod: *mut ndpi_detection_module_struct,
        protoId: ::std::os::raw::c_int,
        ...
    );
}
unsafe extern "C" {
    pub fn ndpi_parse_ip_string(
        ip_str: *const ::std::os::raw::c_char,
        parsed_ip: *mut ndpi_ip_addr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_get_ip_string(
        ip: *const ndpi_ip_addr_t,
        buf: *mut ::std::os::raw::c_char,
        buf_len: u_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_is_ipv6(ip: *const ndpi_ip_addr_t) -> u_int8_t;
}
unsafe extern "C" {
    pub fn ndpi_search_tcp_or_udp(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    );
}
unsafe extern "C" {
    #[doc = " Checks when the @p payload starts with the string literal @p str.\n When the string is larger than the payload, check fails.\n @return non-zero if check succeeded"]
    pub fn ndpi_match_prefix(
        payload: *const u_int8_t,
        payload_len: usize,
        str_: *const ::std::os::raw::c_char,
        str_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_handle_ipv6_extension_headers(
        l3len: u_int16_t,
        l4ptr: *mut *const u_int8_t,
        l4len: *mut u_int16_t,
        nxt_hdr: *mut u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_set_risk(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        r: ndpi_risk_enum,
        risk_message: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn ndpi_unset_risk(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        r: ndpi_risk_enum,
    );
}
unsafe extern "C" {
    pub fn ndpi_isset_risk(flow: *mut ndpi_flow_struct, r: ndpi_risk_enum)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_is_printable_buffer(buf: *const u_int8_t, len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_normalize_printable_string(
        str_: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_is_valid_hostname(str_: *mut ::std::os::raw::c_char, len: usize) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_entropy(buf: *const u_int8_t, len: usize) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_entropy2str(
        entropy: f32,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_entropy2risk(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    );
}
unsafe extern "C" {
    #[doc = " Check if a string is encoded with punycode\n ( https://tools.ietf.org/html/rfc3492 )\n\n @par    buff = pointer to the string to check\n @par    len  = len of the string\n @return 1 if the string is punycoded;\n         else 0\n"]
    pub fn ndpi_check_punycode_string(
        buff: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the size of the flow struct\n\n @return the size of the flow struct\n"]
    pub fn ndpi_detection_get_sizeof_ndpi_flow_struct() -> u_int32_t;
}
unsafe extern "C" {
    #[doc = " Match a string against an automaton and retrieve its associated numeric value.\n This function is similar to ndpi_match_string_subprotocol() but is used for\n matching raw IDs that were added via ndpi_add_string_value_to_automa().\n\n @param _automa Automaton created with ndpi_init_automa()\n @param string_to_match String to search for\n @param match_len Length of the string to match\n @param num Pointer to store the associated numeric value (output parameter)\n @return 1 if a match was found, 0 otherwise"]
    pub fn ndpi_match_string_value(
        _automa: *mut ::std::os::raw::c_void,
        string_to_match: *mut ::std::os::raw::c_char,
        match_len: u_int,
        num: *mut u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the protocol error code of a given flow\n\n @par    flow    = the flow to analyze\n @return the error code or 0 otherwise\n"]
    pub fn ndpi_get_flow_error_code(flow: *mut ndpi_flow_struct) -> u_int32_t;
}
unsafe extern "C" {
    #[doc = " Allocate memory using nDPI's memory allocator.\n This function can be customized via ndpi_set_memory_alloction_functions() to use a custom allocator.\n\n @param size Number of bytes to allocate\n @return Pointer to allocated memory, or NULL on failure"]
    pub fn ndpi_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Allocate and zero-initialize memory using nDPI's memory allocator.\n This function can be customized via ndpi_set_memory_alloction_functions() to use a custom allocator.\n\n @param count Number of elements to allocate\n @param size Size of each element in bytes\n @return Pointer to zero-initialized memory, or NULL on failure"]
    pub fn ndpi_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Reallocate memory using nDPI's memory allocator.\n This function can be customized via ndpi_set_memory_alloction_functions() to use a custom allocator.\n\n @param ptr Pointer to previously allocated memory (or NULL for new allocation)\n @param old_size Current size of the allocated block in bytes\n @param new_size Desired new size in bytes\n @return Pointer to reallocated memory, or NULL on failure"]
    pub fn ndpi_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Allocate aligned memory using nDPI's memory allocator.\n This function can be customized via ndpi_set_memory_alloction_functions() to use a custom allocator.\n\n @param the address of the allocated memory will be a multiple of `alignment`\n @param size Number of bytes to allocate\n @return Pointer to allocated memory, or NULL on failure"]
    pub fn ndpi_aligned_malloc(alignment: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Duplicate a string using nDPI's memory allocator.\n The returned string must be freed with ndpi_free().\n\n @param s String to duplicate (null-terminated)\n @return Pointer to newly allocated string copy, or NULL on failure"]
    pub fn ndpi_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Duplicate a string with length limit using nDPI's memory allocator.\n The returned string must be freed with ndpi_free().\n\n @param s String to duplicate\n @param size Maximum number of characters to copy (excluding null terminator)\n @return Pointer to newly allocated string copy, or NULL on failure"]
    pub fn ndpi_strndup(
        s: *const ::std::os::raw::c_char,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Free memory allocated by nDPI's memory allocator.\n This function can be customized via ndpi_set_memory_alloction_functions() to use a custom deallocator.\n\n @param ptr Pointer to memory to free (NULL is safe to pass)"]
    pub fn ndpi_free(ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Free aligned memory allocated by nDPI's memory allocator.\n This function can be customized via ndpi_set_memory_alloction_functions() to use a custom deallocator.\n\n @param ptr Pointer to memory to free (NULL is safe to pass)"]
    pub fn ndpi_aligned_free(ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Allocate memory for flow-specific data using nDPI's flow allocator.\n Flow memory can use a separate allocator from general memory for better\n memory management in high-throughput scenarios.\n This function can be customized via ndpi_set_memory_alloction_functions() to use a custom allocator.\n\n @param size Number of bytes to allocate\n @return Pointer to allocated memory, or NULL on failure"]
    pub fn ndpi_flow_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Free memory allocated by ndpi_flow_malloc().\n This function can be customized via ndpi_set_memory_alloction_functions() to use a custom deallocator.\n\n @param ptr Pointer to flow memory to free (NULL is safe to pass)"]
    pub fn ndpi_flow_free(ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Get the total amount of memory allocated by nDPI.\n This tracks memory allocated via ndpi_malloc(), ndpi_calloc(), ndpi_realloc(),\n ndpi_strdup(), and ndpi_strndup() (but not flow allocations).\n\n @return Total number of bytes currently allocated"]
    pub fn ndpi_get_tot_allocated_memory() -> u_int32_t;
}
unsafe extern "C" {
    #[doc = " Remove leading and trailing whitespace from a string in-place.\n\n @param ptr Pointer to the string to process (modified in-place)\n @param ptr_len Pointer to the string length (updated to new length after stripping)\n @return Pointer to the start of the trimmed string (within the original buffer)"]
    pub fn ndpi_strip_leading_trailing_spaces(
        ptr: *mut ::std::os::raw::c_char,
        ptr_len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Finds the first occurrence of the substring 'needle' in the string 'haystack'.\n\n This function is similar to the standard `strstr()` function, but it has an additional parameter `len` that\n specifies the maximum length of the search.\n\n @param haystack The string to search in.\n @param needle The substring to search for.\n @param len The maximum length of the search.\n @return Pointer to the first occurrence of 'needle' in 'haystack', or NULL if no match is found."]
    pub fn ndpi_strnstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Same as ndpi_strnstr but case insensitive\n\n @par    s     = string to parse\n @par    find  = string to match with -s-\n @par    slen  = max length to match between -s- and -find-\n @return a pointer to the beginning of the located substring;\n         NULL if the substring is not found\n"]
    pub fn ndpi_strncasestr(
        s: *const ::std::os::raw::c_char,
        find: *const ::std::os::raw::c_char,
        slen: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the nDPI protocol id for IP-based protocol detection\n\n @par    ndpi_struct  = the struct created for the protocol detection\n @par    pin          = IP host address (MUST BE in network byte order):\n                        See man(7) ip for details\n @return the nDPI protocol ID\n"]
    pub fn ndpi_network_ptree_match(
        ndpi_struct: *mut ndpi_detection_module_struct,
        pin: *mut in_addr,
    ) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_network_ptree6_match(
        ndpi_str: *mut ndpi_detection_module_struct,
        pin: *mut in6_addr,
    ) -> u_int16_t;
}
unsafe extern "C" {
    #[doc = " Returns the nDPI protocol id for IP+port-based protocol detection\n\n @par    ndpi_struct  = the struct created for the protocol detection\n @par    pin          = IP host address (MUST BE in network byte order):\n                        See man(7) ip for details\n @par    port         = The port (MUST BE in network byte order) or\n                        0 if ignored\n @return the nDPI protocol ID\n"]
    pub fn ndpi_network_port_ptree_match(
        ndpi_struct: *mut ndpi_detection_module_struct,
        pin: *mut in_addr,
        port: u_int16_t,
    ) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_network_port_ptree6_match(
        ndpi_struct: *mut ndpi_detection_module_struct,
        pin: *mut in6_addr,
        port: u_int16_t,
    ) -> u_int16_t;
}
unsafe extern "C" {
    #[doc = " Returns a new initialized global context.\n\n @return  the initialized global context\n"]
    pub fn ndpi_global_init() -> *mut ndpi_global_context;
}
unsafe extern "C" {
    #[doc = " Deinit a properly initialized global context.\n\n @par g_ctx = global context to free/deinit\n"]
    pub fn ndpi_global_deinit(g_ctx: *mut ndpi_global_context);
}
unsafe extern "C" {
    #[doc = " Returns a new initialized detection module\n Note that before you can use it you can still load\n hosts and do other things. As soon as you are ready to use\n it do not forget to call first ndpi_finalize_initialization()\n\n You can call this function multiple times, (i.e. to create multiple\n independent detection contexts) but all these calls MUST NOT run\n in parallel\n\n @par g_ctx = global context associated to the new detection module; NULL if no global context is needed\n @return  the initialized detection module\n"]
    pub fn ndpi_init_detection_module(
        g_ctx: *mut ndpi_global_context,
    ) -> *mut ndpi_detection_module_struct;
}
unsafe extern "C" {
    #[doc = " Completes the initialization (2nd step)\n\n @par ndpi_str = the struct created for the protocol detection\n\n @return 0 on success\n"]
    pub fn ndpi_finalize_initialization(
        ndpi_str: *mut ndpi_detection_module_struct,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Frees the dynamic memory allocated members in the specified flow\n\n @par flow  = the flow struct which dynamic allocated members should be deallocated\n"]
    pub fn ndpi_free_flow_data(flow: *mut ndpi_flow_struct);
}
unsafe extern "C" {
    #[doc = " Frees the dynamic memory allocated members in the specified flow and the flow struct itself\n\n @par flow  = the flow struct and its dynamic allocated members that should be deallocated\n"]
    pub fn ndpi_free_flow(flow: *mut ndpi_flow_struct);
}
unsafe extern "C" {
    #[doc = " Destroys the detection module\n\n @par ndpi_struct  = the struct to clearing for the detection module\n"]
    pub fn ndpi_exit_detection_module(ndpi_struct: *mut ndpi_detection_module_struct);
}
unsafe extern "C" {
    #[doc = "  Function to be called before we give up with detection for a given flow.\n  This function reduces the NDPI_UNKNOWN_PROTOCOL detection\n\n @par    ndpi_struct  = the detection module\n @par    flow         = the flow given for the detection module\n @return the detected protocol even if the flow is not completed;\n"]
    pub fn ndpi_detection_giveup(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> ndpi_protocol;
}
unsafe extern "C" {
    #[doc = " Processes one packet and returns the ID of the detected protocol.\n This is the MAIN PACKET PROCESSING FUNCTION.\n\n @par    ndpi_struct    = the detection module\n @par    flow           = pointer to the connection state machine\n @par    packet         = unsigned char pointer to the Layer 3 (IP header)\n @par    packetlen      = the length of the packet\n @par    packet_time_ms = the current timestamp for the packet (expressed in msec)\n @par    input_info     = (optional) flow information provided by the (external) flow manager\n @return the detected ID of the protocol\n"]
    pub fn ndpi_detection_process_packet(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        packet: *const ::std::os::raw::c_uchar,
        packetlen: ::std::os::raw::c_ushort,
        packet_time_ms: u_int64_t,
        input_info: *mut ndpi_flow_input_info,
    ) -> ndpi_protocol;
}
unsafe extern "C" {
    #[doc = " Get the main protocol of the passed flows for the detected module\n\n\n @par    flow         = the flow given for the detection module\n @return the ID of the master protocol detected\n"]
    pub fn ndpi_get_flow_masterprotocol(flow: *mut ndpi_flow_struct) -> u_int16_t;
}
unsafe extern "C" {
    #[doc = " Get the app protocol of the passed flows for the detected module\n\n\n @par    flow         = the flow given for the detection module\n @return the ID of the app protocol detected\n"]
    pub fn ndpi_get_flow_appprotocol(flow: *mut ndpi_flow_struct) -> u_int16_t;
}
unsafe extern "C" {
    #[doc = " Get the category of the passed flows for the detected module\n\n\n @par    flow         = the flow given for the detection module\n @return the ID of the category\n"]
    pub fn ndpi_get_flow_category(flow: *mut ndpi_flow_struct) -> ndpi_protocol_category_t;
}
unsafe extern "C" {
    #[doc = " Get the ndpi protocol data of the passed flows for the detected module\n\n\n @par    flow         = the flow given for the detection module\n @par    ndpi_proto   = the output struct where to store the requested information\n"]
    pub fn ndpi_get_flow_ndpi_proto(flow: *mut ndpi_flow_struct, ndpi_proto: *mut ndpi_proto);
}
unsafe extern "C" {
    #[doc = " Query the pointer to the layer 4 packet\n\n @par    l3 = pointer to the layer 3 data\n @par    l3_len = length of the layer 3 data\n @par    l4_return = address to the pointer of the layer 4 data if return value == 0, else undefined\n @par    l4_len_return = length of the layer 4 data if return value == 0, else undefined\n @par    l4_protocol_return = protocol of the layer 4 data if return value == 0, undefined otherwise\n @par    flags = limit operation on ipv4 or ipv6 packets. Possible values: NDPI_DETECTION_ONLY_IPV4 - NDPI_DETECTION_ONLY_IPV6 - 0 (any)\n @return 0 if layer 4 data could be found correctly;\nelse != 0\n"]
    pub fn ndpi_detection_get_l4(
        l3: *const u_int8_t,
        l3_len: u_int16_t,
        l4_return: *mut *const u_int8_t,
        l4_len_return: *mut u_int16_t,
        l4_protocol_return: *mut u_int8_t,
        flags: u_int32_t,
    ) -> u_int8_t;
}
unsafe extern "C" {
    #[doc = " Search and return the protocol based on matched ports\n\n @par    ndpi_struct  = the detection module\n @par    shost        = source address in host byte order\n @par    sport        = source port number\n @par    dhost        = destination address in host byte order\n @par    dport        = destination port number\n @return the struct ndpi_protocol that match the port base protocol\n"]
    pub fn ndpi_find_port_based_protocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        shost: u_int32_t,
        sport: u_int16_t,
        dhost: u_int32_t,
        dport: u_int16_t,
    ) -> ndpi_protocol;
}
unsafe extern "C" {
    #[doc = " Search and return the protocol guessed that is undetected\n\n @par    ndpi_struct  = the detection module\n @par    flow         = the flow we're trying to guess, NULL if not available\n @par    proto        = the l4 protocol number\n @return the struct ndpi_protocol that match the port base protocol\n"]
    pub fn ndpi_guess_undetected_protocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        proto: u_int8_t,
    ) -> ndpi_protocol;
}
unsafe extern "C" {
    #[doc = " Superset of ndpi_guess_undetected_protocol with additional IPv4 guess based on host/port\n\n @par    ndpi_struct  = the detection module\n @par    flow         = the flow we're trying to guess, NULL if not available\n @par    proto        = the l4 protocol number\n @par    shost        = source address in host byte order\n @par    sport        = source port number\n @par    dhost        = destination address in host byte order\n @par    dport        = destination port number\n @return the struct ndpi_protocol that match the port base protocol\n"]
    pub fn ndpi_guess_undetected_protocol_v4(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        proto: u_int8_t,
        shost: u_int32_t,
        sport: u_int16_t,
        dhost: u_int32_t,
        dport: u_int16_t,
    ) -> ndpi_protocol;
}
unsafe extern "C" {
    #[doc = " Check if the string passed match with a protocol\n\n @par    ndpi_struct         = the detection module\n @par    string_to_match     = the string to match\n @par    string_to_match_len = the length of the string\n @par    ret_match           = completed returned match information\n @return the ID of the matched subprotocol;\n         -1 if automa is not finalized;\n         -2 if automa==NULL or string_to_match==NULL or empty string_to_match\n"]
    pub fn ndpi_match_string_subprotocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        string_to_match: *mut ::std::os::raw::c_char,
        string_to_match_len: u_int,
        ret_match: *mut ndpi_protocol_match_result,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the host passed match with a protocol\n\n @par    ndpi_struct         = the detection module\n @par    flow                = the flow where match the host\n @par    string_to_match     = the string to match\n @par    string_to_match_len = the length of the string\n @par    ret_match           = completed returned match information\n @par    master_protocol_id  = value of the ID associated to the master protocol detected\n @par    update_flow_classification = update or not protocol (sub)classification\n @return the ID of the matched subprotocol\n"]
    pub fn ndpi_match_host_subprotocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        string_to_match: *mut ::std::os::raw::c_char,
        string_to_match_len: u_int,
        ret_match: *mut ndpi_protocol_match_result,
        master_protocol_id: u_int16_t,
        update_flow_classification: ::std::os::raw::c_int,
    ) -> u_int16_t;
}
unsafe extern "C" {
    #[doc = " Check if the string content passed match with a protocol\n\n @par    ndpi_struct         = the detection module\n @par    flow                = the flow where match the host\n @par    subprotocol_id      = subprotocol id"]
    pub fn ndpi_check_subprotocol_risk(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        subprotocol_id: u_int16_t,
    );
}
unsafe extern "C" {
    #[doc = " Check if the string -bigram_to_match- match with a bigram of -automa-\n\n @par     ndpi_mod         = the detection module\n @par     automa           = the struct ndpi_automa for the bigram\n @par     bigram_to_match  = the bigram string to match\n @return  0\n"]
    pub fn ndpi_match_bigram(
        bigram_to_match: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write the protocol name in the buffer -buf- as master_protocol.protocol\n\n @par     ndpi_mod      = the detection module\n @par     proto         = the struct ndpi_master_app_protocol contain the protocols name\n @par     buf           = the buffer to write the name of the protocols\n @par     buf_len       = the length of the buffer\n @return  the buffer contains the master_protocol and protocol name\n"]
    pub fn ndpi_protocol2name(
        ndpi_mod: *mut ndpi_detection_module_struct,
        proto: ndpi_master_app_protocol,
        buf: *mut ::std::os::raw::c_char,
        buf_len: u_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Same as ndpi_protocol2name() with the difference that the numeric protocol\n name is returned\n\n @par     proto         = the struct ndpi_master_app_protocol contain the protocols name\n @par     buf           = the buffer to write the name of the protocols\n @par     buf_len       = the length of the buffer\n @return  the buffer contains the master_protocol and protocol name\n"]
    pub fn ndpi_protocol2id(
        proto: ndpi_master_app_protocol,
        buf: *mut ::std::os::raw::c_char,
        buf_len: u_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Find out if a given category is custom/user-defined\n\n @par     category      = the category associated to the protocol\n @return  True if this is a custom user category, false otherwise\n"]
    pub fn ndpi_is_custom_category(category: ndpi_protocol_category_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Find out if a given protocol is custom/user-defined\n\n @par     ndpi_str      = the detection module\n @par     proto_id      = the proto_id to check\n @return  True if this is a custom user protocol, false otherwise (nDPI protocol already supported in the engine)\n"]
    pub fn ndpi_is_custom_protocol(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto_id: u_int16_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Overwrite a protocol category defined by nDPI with the custom category\n\n @par     ndpi_mod      = the detection module\n @par     protoId       = the protocol identifier to overwrite\n @par     breed         = the breed to be associated to the protocol\n"]
    pub fn ndpi_set_proto_breed(
        ndpi_mod: *mut ndpi_detection_module_struct,
        protoId: u_int16_t,
        breed: ndpi_protocol_breed_t,
    );
}
unsafe extern "C" {
    #[doc = " Overwrite a protocol category defined by nDPI with the custom category\n\n @par     ndpi_mod      = the detection module\n @par     protoId       = the protocol identifier to overwrite\n @par     category      = the category associated to the protocol\n"]
    pub fn ndpi_set_proto_category(
        ndpi_mod: *mut ndpi_detection_module_struct,
        protoId: u_int16_t,
        protoCategory: ndpi_protocol_category_t,
    );
}
unsafe extern "C" {
    #[doc = " Find the QoE category for the specified protocol\n\n @par     ndpi_mod      = the detection module\n @par     protoId       = the protocol identifier we're searching\n"]
    pub fn ndpi_find_protocol_qoe(
        ndpi_str: *mut ndpi_detection_module_struct,
        protoId: u_int16_t,
    ) -> ndpi_protocol_qoe_category_t;
}
unsafe extern "C" {
    #[doc = " Return the name of a RTP payload type\n\n @par     payload_type     = the RTP payload type\n @par     evs_payload_type = EVS payload type (only in case payload_type is EVS)\n @return  The symbolic payload type or \"Unknown\" if not found"]
    pub fn ndpi_rtp_payload_type2str(
        payload_type: u_int8_t,
        evs_payload_type: u_int32_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Check if subprotocols of the specified master protocol are just\n informative (and not real)\n\n @par ndpi_mod          = the detection module\n @par     protoId       = the (master) protocol identifier to query\n @return  1 = the subprotocol is informative, 0 otherwise.\n"]
    pub fn ndpi_is_subprotocol_informative(
        ndpi_mod: *mut ndpi_detection_module_struct,
        protoId: u_int16_t,
    ) -> u_int8_t;
}
unsafe extern "C" {
    #[doc = " Set hostname-based protocol\n\n @par ndpi_mod          = the detection module\n @par flow              = the flow to which this communication belongs to\n @par master_protocol   = the master protocol for this flow\n @par name              = the host name\n @par name_len          = length of the host name\n"]
    pub fn ndpi_match_hostname_protocol(
        ndpi_mod: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        master_protocol: u_int16_t,
        name: *mut ::std::os::raw::c_char,
        name_len: u_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get protocol category as string\n\n @par     mod           = the detection module\n @par     category      = the category associated to the protocol\n @return  the string name of the category\n"]
    pub fn ndpi_category_get_name(
        ndpi_mod: *mut ndpi_detection_module_struct,
        category: ndpi_protocol_category_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get classification confidence as string\n\n @par     confidence      = the confidence value\n @return  the string name of the confidence result\n"]
    pub fn ndpi_confidence_get_name(confidence: ndpi_confidence_t)
        -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get FPC confidence as string\n\n @par     confidence      = the confidence value\n @return  the string name of the confidence result\n"]
    pub fn ndpi_fpc_confidence_get_name(
        fpc_confidence: ndpi_fpc_confidence_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Set protocol category string\n\n @par     mod           = the detection module\n @par     category      = the category associated to the protocol\n @par     name          = the string name of the category\n"]
    pub fn ndpi_category_set_name(
        ndpi_mod: *mut ndpi_detection_module_struct,
        category: ndpi_protocol_category_t,
        name: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Get protocol category\n\n @par     ndpi_mod      = the detection module\n @par     proto         = the struct ndpi_protocol contain the protocols name\n @return  the protocol category"]
    pub fn ndpi_get_proto_category(
        ndpi_mod: *mut ndpi_detection_module_struct,
        proto: ndpi_protocol,
    ) -> ndpi_protocol_category_t;
}
unsafe extern "C" {
    #[doc = " Get the protocol name associated to the ID\n\n @par     mod           = the detection module\n @par     proto_id      = the ID of the protocol\n @return  the buffer contains the master_protocol and protocol name\n"]
    pub fn ndpi_get_proto_name(
        mod_: *mut ndpi_detection_module_struct,
        proto_id: u_int16_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return the protocol breed ID associated to the protocol\n\n @par     ndpi_struct   = the detection module\n @par     proto         = the ID of the protocol\n @return  the breed ID associated to the protocol\n"]
    pub fn ndpi_get_proto_breed(
        ndpi_struct: *mut ndpi_detection_module_struct,
        proto: u_int16_t,
    ) -> ndpi_protocol_breed_t;
}
unsafe extern "C" {
    #[doc = " Get the protocol breed ID associated to the breed name\n\n @par     name          = the string name of the breed\n @return  the breed ID associated to the name, or NDPI_PROTOCOL_UNRATED if not found\n"]
    pub fn ndpi_get_breed_by_name(name: *const ::std::os::raw::c_char) -> ndpi_protocol_breed_t;
}
unsafe extern "C" {
    #[doc = " Return the string name of the protocol breed\n\n @par     ndpi_struct   = the detection module\n @par     breed_id      = the breed ID associated to the protocol\n @return  the string name of the breed ID\n"]
    pub fn ndpi_get_proto_breed_name(
        breed_id: ndpi_protocol_breed_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return the name of the protocol given its ID.\n\n @par     ndpi_mod   = the detection module\n @par     name       = the protocol name. You can specify TLS or YouYube but not TLS.YouTube (se ndpi_get_protocol_by_name in this case)\n @return  the ID of the protocol\n"]
    pub fn ndpi_get_proto_by_name(
        ndpi_mod: *const ndpi_detection_module_struct,
        name: *const ::std::os::raw::c_char,
    ) -> u_int16_t;
}
unsafe extern "C" {
    #[doc = " Return the name of the protocol given its ID\n\n @par     ndpi_mod   = the detection module\n @par     id         = the protocol id\n @return  the name of the protocol\n"]
    pub fn ndpi_get_proto_by_id(
        ndpi_mod: *const ndpi_detection_module_struct,
        id: u_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return the name of the protocol given its ID. You can specify TLS.YouTube or just TLS\n\n @par     ndpi_mod   = the detection module\n @par     id         = the protocol id\n @return  the name of the protocol\n"]
    pub fn ndpi_get_protocol_by_name(
        ndpi_str: *mut ndpi_detection_module_struct,
        name: *const ::std::os::raw::c_char,
    ) -> ndpi_master_app_protocol;
}
unsafe extern "C" {
    #[doc = " Return the ID of the category\n\n @par     ndpi_mod   = the detection module\n @par     proto      = the category name\n @return  the ID of the category\n"]
    pub fn ndpi_get_category_id(
        ndpi_mod: *mut ndpi_detection_module_struct,
        cat: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write the list of the supported protocols\n\n @par  ndpi_mod = the detection module"]
    pub fn ndpi_dump_protocols(mod_: *mut ndpi_detection_module_struct, dump_out: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Generate Options list used in OPNsense firewall plugin\n\n @par  opt = The Option list to generate\n @par  dump_out = Output stream for generated options"]
    pub fn ndpi_generate_options(opt: u_int, dump_out: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Write the list of the scores and their associated risks\n\n @par  dump_out = Output stream for dumped risk scores"]
    pub fn ndpi_dump_risks_score(dump_out: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Read a file and load the protocols\n\n Format: <tcp|udp>:<port>,<tcp|udp>:<port>,.....@<proto>\n\n Example:\n tcp:80,tcp:3128@HTTP\n udp:139@NETBIOS\n\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 generic error\n          -2 memory allocation error\n"]
    pub fn ndpi_load_protocols_file(
        ndpi_mod: *mut ndpi_detection_module_struct,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an IP-address based risk mask\n\n @par     ndpi_mod = the detection module\n @par     ip       = the IP address for which you wanna set the mask\n @par     mask     = the IP risk mask\n @return  0 if the rule is loaded correctly;\n          -1 else"]
    pub fn ndpi_add_ip_risk_mask(
        ndpi_mod: *mut ndpi_detection_module_struct,
        ip: *mut ::std::os::raw::c_char,
        mask: ndpi_risk,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a host-address based risk mask\n\n @par     ndpi_mod = the detection module\n @par     host     = the hostname/domain for which you wanna set the mask\n @par     mask     = the host risk mask\n @return  0 if the rule is loaded correctly;\n          -1 else"]
    pub fn ndpi_add_host_risk_mask(
        ndpi_mod: *mut ndpi_detection_module_struct,
        host: *mut ::std::os::raw::c_char,
        mask: ndpi_risk,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a trusted certificate issuer DN\n\n @par     ndpi_mod = the detection module\n @par     dn       = the issuer DN as it appears in the certificate (example \"CN=813845657003339838, O=Code42, OU=TEST, ST=MN, C=US\")\n @return  0 if the rule is loaded correctly; < 0 in case an error is detected"]
    pub fn ndpi_add_trusted_issuer_dn(
        ndpi_mod: *mut ndpi_detection_module_struct,
        dn: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read a file and load the categories\n\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @par     user_data = pointer to some user data value\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_categories_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Loads a file (separated by <cr>) of domain names associated with the specified category\n\n @par     ndpi_mod    = the detection module\n @par     path        = the path of the file\n @par     category_id = Id of the category to which domains will be associated\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_category_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *mut ::std::os::raw::c_char,
        category_id: ndpi_protocol_category_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Load files (whose name is <categoryid>_<label>.<extension>) stored\n in a directory and bind each domain to the specified category.\n\n @par     ndpi_mod    = the detection module\n @par     path        = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_categories_dir(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Load files (whose name is <protocolid>_<label>.<extension>) stored\n in a directory and binds each IP/network to the specified protocol.\n This function is used to bind IP addresses to protocols\n\n @par     ndpi_mod    = the detection module\n @par     path        = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_protocols_dir(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read a file and load the list of risky domains\n\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_risk_domain_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read a file and load the list of malicious JA4 signatures\n\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_malicious_ja4_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read a file and load the list of malicious SSL certificate SHA1 fingerprints.\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_malicious_sha1_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_add_tcp_fingerprint(
        ndpi_str: *mut ndpi_detection_module_struct,
        fingerprint: *mut ::std::os::raw::c_char,
        os: ndpi_os,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_load_tcp_fingerprint_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_load_tcp_fingerprints(ndpi_str: *mut ndpi_detection_module_struct);
}
unsafe extern "C" {
    pub fn ndpi_get_os_from_tcp_fingerprint(
        ndpi_str: *mut ndpi_detection_module_struct,
        tcp_fingerprint: *mut ::std::os::raw::c_char,
    ) -> ndpi_os;
}
unsafe extern "C" {
    #[doc = " Get the total number of the defined protocols (internals and custom).\n It can be called only with finalized context, i.e. after having called\n ndpi_finalize_initialization()\n\n @par     ndpi_mod = the detection module\n @return  the number of protocols\n"]
    pub fn ndpi_get_num_protocols(ndpi_mod: *mut ndpi_detection_module_struct) -> u_int;
}
unsafe extern "C" {
    #[doc = " Get the nDPI version release\n\n @return the NDPI_GIT_RELEASE\n"]
    pub fn ndpi_revision() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Set the automa for the protocol search\n\n @par ndpi_struct = the detection module\n @par automa      = the automa to match\n"]
    pub fn ndpi_set_automa(
        ndpi_struct: *mut ndpi_detection_module_struct,
        automa: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Init Aho-Corasick automata\n\n @return  The requested automata, or NULL if an error occurred\n"]
    pub fn ndpi_init_automa() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn ndpi_init_automa_domain() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Free Aho-Corasick automata allocated with ndpi_init_automa();\n\n @par     The automata initialized with ndpi_init_automa();\n"]
    pub fn ndpi_free_automa(_automa: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Add a string to match to an automata\n\n @par     The automata initialized with ndpi_init_automa();\n @par     The (sub)string to search (malloc'ed memory)\n @par     The number associated with this string\n @return  0 in case of no error, or -2 if the string has been already added, or -1 if an error occurred.\n"]
    pub fn ndpi_add_string_value_to_automa(
        _automa: *mut ::std::os::raw::c_void,
        str_: *mut ::std::os::raw::c_char,
        num: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a string to match to an automata. Same as ndpi_add_string_value_to_automa() with num set to 1\n\n @par     The automata initialized with ndpi_init_automa();\n @par     The (sub)string to search (malloc'ed memory)\n @return  0 in case of no error, or -1 if an error occurred.\n"]
    pub fn ndpi_add_string_to_automa(
        _automa: *mut ::std::os::raw::c_void,
        str_: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Finalize the automa (necessary before start searching)\n\n @par     The automata initialized with ndpi_init_automa();\n"]
    pub fn ndpi_finalize_automa(_automa: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Get the automa statistics\n\n @par     The automata initialized with ndpi_init_automa();\n"]
    pub fn ndpi_automa_get_stats(
        _automa: *mut ::std::os::raw::c_void,
        stats: *mut ndpi_automa_stats,
    );
}
unsafe extern "C" {
    #[doc = " Get the statistics of one of the automas used internally by the library\n\n @par     ndpi_mod = the detection module\n @par     automa_type = of which automa we want the stats\n @par     stats = buffer where to save the stats\n @return  0 in case of no error, or -1 if an error occurred.\n"]
    pub fn ndpi_get_automa_stats(
        ndpi_struct: *mut ndpi_detection_module_struct,
        automa_type: automa_type,
        stats: *mut ndpi_automa_stats,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a string to match to an automata\n\n @par     The automata initialized with ndpi_init_automa();\n @par     The (sub)string to search\n @return  0 in case of match, or -1 if no match, or -2 if an error occurred.\n"]
    pub fn ndpi_match_string(
        _automa: *mut ::std::os::raw::c_void,
        string_to_match: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_load_ip_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ip_address_and_mask: *const ::std::os::raw::c_char,
        category: ndpi_protocol_category_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_load_hostname_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        name_to_add: *const ::std::os::raw::c_char,
        category: ndpi_protocol_category_t,
        breed: ndpi_protocol_breed_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_load_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ip_or_name: *const ::std::os::raw::c_char,
        category: ndpi_protocol_category_t,
        breed: ndpi_protocol_breed_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_enable_loaded_categories(
        ndpi_struct: *mut ndpi_detection_module_struct,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_find_ipv4_category_userdata(
        ndpi_str: *mut ndpi_detection_module_struct,
        saddr: u_int32_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn ndpi_find_ipv6_category_userdata(
        ndpi_str: *mut ndpi_detection_module_struct,
        saddr: *mut in6_addr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn ndpi_fill_ip_protocol_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        saddr: u_int32_t,
        daddr: u_int32_t,
        ret: *mut ndpi_protocol,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_fill_ipv6_protocol_category(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        saddr: *mut in6_addr,
        daddr: *mut in6_addr,
        ret: *mut ndpi_protocol,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_match_custom_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        name: *mut ::std::os::raw::c_char,
        name_len: u_int,
        id: *mut ndpi_protocol_category_t,
        breed: *mut ndpi_protocol_breed_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_get_custom_category_match(
        ndpi_struct: *mut ndpi_detection_module_struct,
        name_or_ip: *mut ::std::os::raw::c_char,
        name_len: u_int,
        category: *mut ndpi_protocol_category_t,
        breed: *mut ndpi_protocol_breed_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_map_user_proto_id_to_ndpi_id(
        ndpi_str: *mut ndpi_detection_module_struct,
        user_proto_id: u_int16_t,
    ) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_map_ndpi_id_to_user_proto_id(
        ndpi_str: *mut ndpi_detection_module_struct,
        ndpi_proto_id: u_int16_t,
    ) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_get_l4_proto_info(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ndpi_proto_id: u_int16_t,
    ) -> ndpi_l4_proto_info;
}
unsafe extern "C" {
    pub fn ndpi_get_l4_proto_name(proto: ndpi_l4_proto_info) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_get_lower_proto(proto: ndpi_master_app_protocol) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_get_upper_proto(proto: ndpi_master_app_protocol) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_is_proto(proto: ndpi_master_app_protocol, p: u_int16_t) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_is_proto_unknown(proto: ndpi_master_app_protocol) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_is_proto_equals(
        to_check: ndpi_master_app_protocol,
        to_match: ndpi_master_app_protocol,
        exact_match_only: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_stack_get_lower_proto(s: *mut ndpi_proto_stack) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_stack_get_upper_proto(s: *mut ndpi_proto_stack) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_stack_contains(s: *mut ndpi_proto_stack, proto_id: u_int16_t) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_stack_is_tls_like(s: *mut ndpi_proto_stack) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_stack_is_http_like(s: *mut ndpi_proto_stack) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_stack2str(
        ndpi_str: *mut ndpi_detection_module_struct,
        stack: *mut ndpi_proto_stack,
        buf: *mut ::std::os::raw::c_char,
        buf_len: u_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_get_proto_defaults(
        ndpi_mod: *mut ndpi_detection_module_struct,
    ) -> *mut ndpi_proto_defaults_t;
}
unsafe extern "C" {
    pub fn ndpi_get_ndpi_detection_module_size() -> u_int;
}
unsafe extern "C" {
    pub fn ndpi_get_current_time(flow: *mut ndpi_flow_struct) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_lru_cache_init(
        num_entries: u_int32_t,
        ttl: u_int32_t,
        shared: ::std::os::raw::c_int,
    ) -> *mut ndpi_lru_cache;
}
unsafe extern "C" {
    pub fn ndpi_lru_free_cache(c: *mut ndpi_lru_cache);
}
unsafe extern "C" {
    pub fn ndpi_lru_find_cache(
        c: *mut ndpi_lru_cache,
        key: u_int64_t,
        value: *mut u_int16_t,
        clean_key_when_found: u_int8_t,
        now_sec: u_int32_t,
    ) -> u_int8_t;
}
unsafe extern "C" {
    pub fn ndpi_lru_add_to_cache(
        c: *mut ndpi_lru_cache,
        key: u_int64_t,
        value: u_int16_t,
        now_sec: u_int32_t,
    );
}
unsafe extern "C" {
    pub fn ndpi_lru_get_stats(c: *mut ndpi_lru_cache, stats: *mut ndpi_lru_cache_stats);
}
unsafe extern "C" {
    pub fn ndpi_get_lru_cache_stats(
        g_ctx: *mut ndpi_global_context,
        ndpi_struct: *mut ndpi_detection_module_struct,
        cache_type: lru_cache_type,
        stats: *mut ndpi_lru_cache_stats,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find a protocol id associated with a string automata\n\n @par     The automata initialized with ndpi_init_automa();\n @par     The (sub)string to search\n @par     The (sub)string length\n @par     The protocol id associated with the matched string or 0 id not found.\n @return  0 in case of match, or -1 if no match, or -2 if an error occurred.\n"]
    pub fn ndpi_match_string_protocol_id(
        _automa: *mut ::std::os::raw::c_void,
        string_to_match: *mut ::std::os::raw::c_char,
        match_len: u_int,
        protocol_id: *mut u_int16_t,
        category: *mut ndpi_protocol_category_t,
        breed: *mut ndpi_protocol_breed_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Handle risk exceptions for a flow by unsetting risks that should be ignored\n based on the exception rules configured via ndpi_load_risk_domain_exceptions().\n\n @param ndpi_str The detection module\n @param flow The flow to process for risk exceptions"]
    pub fn ndpi_handle_risk_exceptions(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    );
}
unsafe extern "C" {
    #[doc = " Set custom memory allocation functions for nDPI's general memory allocator.\n\n @param __ndpi_malloc         Function pointer to the custom malloc implementation\n @param __ndpi_free           Function pointer to the custom free implementation\n @param __ndpi_calloc         Function pointer to the custom calloc implementation\n @param __ndpi_realloc        Function pointer to the custom realloc implementation\n @param __ndpi_aligned_malloc Function pointer to the custom aligned allocation implementation\n @param __ndpi_aligned_free   Function pointer to the custom aligned free implementation\n @param __ndpi_flow_malloc    Function pointer to the custom allocation of flows\n @param __ndpi_flow_free      Function pointer to the custom free of flows\n\n This function is optional, but if used, it MUST be called before ANY other nDPI functions!!\n\n The first 4 parameters are mandatory.\n If you want to set a custom allocator for aligned memory, you must specify `__ndpi_aligned_malloc`\n and `__ndpi_aligned_free`, both\n If you want to set a custom allocator for flow memory, you must specify `__ndpi_flow_malloc`\n and `__ndpi_flow_free`, both\n\n Flow memory can use a separate allocator from general memory for better\n memory management in high-throughput scenarios."]
    pub fn ndpi_set_memory_alloction_functions(
        __ndpi_malloc: ::std::option::Option<
            unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void,
        >,
        __ndpi_free: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
        __ndpi_calloc: ::std::option::Option<
            unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void,
        >,
        __ndpi_realloc: ::std::option::Option<
            unsafe extern "C" fn(
                ptr: *mut ::std::os::raw::c_void,
                size: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        __ndpi_aligned_malloc: ::std::option::Option<
            unsafe extern "C" fn(alignment: usize, size: usize) -> *mut ::std::os::raw::c_void,
        >,
        __ndpi_aligned_free: ::std::option::Option<
            unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
        >,
        __ndpi_flow_malloc: ::std::option::Option<
            unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void,
        >,
        __ndpi_flow_free: ::std::option::Option<
            unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
        >,
    );
}
unsafe extern "C" {
    pub fn ndpi_get_api_version() -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_get_gcrypt_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Compute the Community ID hash for an IPv4 flow.\n Community ID is a standard for flow hashing that enables correlation of\n network traffic across different monitoring tools.\n Specification: https://github.com/corelight/community-id-spec\n\n @param l4_proto Layer 4 protocol (e.g., IPPROTO_TCP, IPPROTO_UDP)\n @param src_ip Source IPv4 address in host byte order\n @param dst_ip Destination IPv4 address in host byte order\n @param src_port Source port (host byte order), or 0 for non-port protocols\n @param dst_port Destination port (host byte order), or 0 for non-port protocols\n @param icmp_type ICMP type (for ICMP), or 0 otherwise\n @param icmp_code ICMP code (for ICMP), or 0 otherwise\n @param hash_buf Buffer to store the resulting hash\n @param hash_buf_len Length of hash_buf (must be at least 20 bytes for SHA1)\n @return 0 on success, -1 on error"]
    pub fn ndpi_flowv4_flow_hash(
        l4_proto: u_int8_t,
        src_ip: u_int32_t,
        dst_ip: u_int32_t,
        src_port: u_int16_t,
        dst_port: u_int16_t,
        icmp_type: u_int8_t,
        icmp_code: u_int8_t,
        hash_buf: *mut u_char,
        hash_buf_len: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compute the Community ID hash for an IPv6 flow.\n Community ID is a standard for flow hashing that enables correlation of\n network traffic across different monitoring tools.\n Specification: https://github.com/corelight/community-id-spec\n\n @param l4_proto Layer 4 protocol (e.g., IPPROTO_TCP, IPPROTO_UDP)\n @param src_ip Source IPv6 address\n @param dst_ip Destination IPv6 address\n @param src_port Source port (host byte order), or 0 for non-port protocols\n @param dst_port Destination port (host byte order), or 0 for non-port protocols\n @param icmp_type ICMPv6 type (for ICMPv6), or 0 otherwise\n @param icmp_code ICMPv6 code (for ICMPv6), or 0 otherwise\n @param hash_buf Buffer to store the resulting hash\n @param hash_buf_len Length of hash_buf (must be at least 20 bytes for SHA1)\n @return 0 on success, -1 on error"]
    pub fn ndpi_flowv6_flow_hash(
        l4_proto: u_int8_t,
        src_ip: *const ndpi_in6_addr,
        dst_ip: *const ndpi_in6_addr,
        src_port: u_int16_t,
        dst_port: u_int16_t,
        icmp_type: u_int8_t,
        icmp_code: u_int8_t,
        hash_buf: *mut u_char,
        hash_buf_len: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_is_safe_ssl_cipher(cipher: u_int32_t) -> u_int8_t;
}
unsafe extern "C" {
    pub fn ndpi_cipher2str(
        cipher: u_int32_t,
        unknown_cipher: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_tunnel2str(tt: ndpi_packet_tunnel) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_guess_host_protocol_id(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_has_human_readable_string(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: u_int,
        min_string_match_len: u_int8_t,
        outbuf: *mut ::std::os::raw::c_char,
        outbuf_len: u_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_get_flow_info(
        flow: *const ndpi_flow_struct,
        l7_protocol: *const ndpi_protocol,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_ssl_version2str(
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        version: u_int16_t,
        unknown_tls_version: *mut u_int8_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_multimedia_flowtype2str(
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        m_types: u_int8_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_quic_version2str(
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        version: u_int32_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_netbios_name_interpret(
        in_: *mut u_char,
        in_len: u_int,
        out: *mut u_char,
        out_len: u_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_patchIPv6Address(str_: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn ndpi_user_pwd_payload_copy(
        dest: *mut u_int8_t,
        dest_len: u_int,
        offset: u_int,
        src: *const u_int8_t,
        src_len: u_int,
    );
}
unsafe extern "C" {
    pub fn ndpi_base64_decode(src: *const u_char, len: usize, out_len: *mut usize) -> *mut u_char;
}
unsafe extern "C" {
    pub fn ndpi_base64_encode(
        bytes_to_encode: *const ::std::os::raw::c_uchar,
        in_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_hex_decode(src: *const u_char, len: usize, out_len: *mut usize) -> *mut u_char;
}
unsafe extern "C" {
    pub fn ndpi_hex_encode(
        bytes_to_encode: *const ::std::os::raw::c_uchar,
        in_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_string_sha1_hash(message: *const u_int8_t, len: usize, hash: *mut u_char);
}
unsafe extern "C" {
    pub fn ndpi_load_ipv4_ptree(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const ::std::os::raw::c_char,
        protocol_id: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_dpi2json(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        l7_protocol: ndpi_protocol,
        serializer: *mut ndpi_serializer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_flow2json(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        ip_version: u_int8_t,
        l4_protocol: u_int8_t,
        vlan_id: u_int16_t,
        src_v4: u_int32_t,
        dst_v4: u_int32_t,
        src_v6: *mut ndpi_in6_addr,
        dst_v6: *mut ndpi_in6_addr,
        src_port: u_int16_t,
        dst_port: u_int16_t,
        l7_protocol: ndpi_protocol,
        serializer: *mut ndpi_serializer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_get_ip_proto_name(
        ip_proto: u_int16_t,
        name: *mut ::std::os::raw::c_char,
        name_len: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_http_method2str(m: ndpi_http_method) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_http_str2method(
        method: *const ::std::os::raw::c_char,
        method_len: u_int16_t,
    ) -> ndpi_http_method;
}
unsafe extern "C" {
    pub fn ndpi_fill_prefix_v4(
        p: *mut ndpi_prefix_t,
        a: *const in_addr,
        b: ::std::os::raw::c_int,
        mb: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_fill_prefix_v6(
        prefix: *mut ndpi_prefix_t,
        addr: *const in6_addr,
        bits: ::std::os::raw::c_int,
        maxbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_fill_prefix_mac(
        prefix: *mut ndpi_prefix_t,
        mac: *mut u_int8_t,
        bits: ::std::os::raw::c_int,
        maxbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_patricia_new(maxbits: u_int16_t) -> *mut ndpi_patricia_tree_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_clone(from: *const ndpi_patricia_tree_t) -> *mut ndpi_patricia_tree_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_destroy(patricia: *mut ndpi_patricia_tree_t, func: ndpi_void_fn_t);
}
unsafe extern "C" {
    pub fn ndpi_patricia_search_exact(
        patricia: *mut ndpi_patricia_tree_t,
        prefix: *mut ndpi_prefix_t,
    ) -> *mut ndpi_patricia_node_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_search_best(
        patricia: *mut ndpi_patricia_tree_t,
        prefix: *mut ndpi_prefix_t,
    ) -> *mut ndpi_patricia_node_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_lookup(
        patricia: *mut ndpi_patricia_tree_t,
        prefix: *mut ndpi_prefix_t,
    ) -> *mut ndpi_patricia_node_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_walk_tree_inorder(
        patricia: *mut ndpi_patricia_tree_t,
        func: ndpi_void_fn3_t,
        data: *mut ::std::os::raw::c_void,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ndpi_patricia_walk_inorder(
        node: *mut ndpi_patricia_node_t,
        func: ndpi_void_fn3_t,
        data: *mut ::std::os::raw::c_void,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ndpi_patricia_remove(
        patricia: *mut ndpi_patricia_tree_t,
        node: *mut ndpi_patricia_node_t,
    );
}
unsafe extern "C" {
    pub fn ndpi_patricia_process(patricia: *mut ndpi_patricia_tree_t, func: ndpi_void_fn2_t);
}
unsafe extern "C" {
    pub fn ndpi_patricia_set_node_u64(node: *mut ndpi_patricia_node_t, value: u_int64_t);
}
unsafe extern "C" {
    pub fn ndpi_patricia_get_node_u64(node: *mut ndpi_patricia_node_t) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_set_node_data(
        node: *mut ndpi_patricia_node_t,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ndpi_patricia_get_node_data(
        node: *mut ndpi_patricia_node_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn ndpi_patricia_get_node_prefix(node: *mut ndpi_patricia_node_t) -> *mut ndpi_prefix_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_get_node_bits(node: *mut ndpi_patricia_node_t) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_get_maxbits(tree: *mut ndpi_patricia_tree_t) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_patricia_get_stats(
        tree: *mut ndpi_patricia_tree_t,
        stats: *mut ndpi_patricia_tree_stats,
    );
}
unsafe extern "C" {
    pub fn ndpi_get_patricia_stats(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ptree_type: ptree_type,
        stats: *mut ndpi_patricia_tree_stats,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_ptree_create() -> *mut ndpi_ptree_t;
}
unsafe extern "C" {
    pub fn ndpi_ptree_insert(
        tree: *mut ndpi_ptree_t,
        addr: *const ndpi_ip_addr_t,
        bits: u_int8_t,
        user_data: u_int64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_ptree_match_addr(
        tree: *mut ndpi_ptree_t,
        addr: *const ndpi_ip_addr_t,
        user_data: *mut u_int64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_load_ptree_file(
        tree: *mut ndpi_ptree_t,
        path: *const ::std::os::raw::c_char,
        protocol_id: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_ptree_destroy(tree: *mut ndpi_ptree_t);
}
unsafe extern "C" {
    pub fn ndpi_is_public_ipv4(a: u_int32_t) -> u_int8_t;
}
unsafe extern "C" {
    pub fn ndpi_htonll(v: u_int64_t) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_ntohll(v: u_int64_t) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_is_encrypted_proto(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto: ndpi_master_app_protocol,
    ) -> u_int8_t;
}
unsafe extern "C" {
    pub fn ndpi_check_dga_name(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        name: *mut ::std::os::raw::c_char,
        is_hostname: u_int8_t,
        check_subproto: u_int8_t,
        flow_fully_classified: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize a serializer handle (allocated by the caller).\n @param serializer The serializer handle\n @param fmt The serialization format (ndpi_serialization_format_json, ndpi_serialization_format_tlv, ndpi_serialization_format_csv)\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_init_serializer(
        serializer: *mut ndpi_serializer,
        fmt: ndpi_serialization_format,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize a serializer handle. Same as ndpi_init_serializer, but with some low-level settings.\n @param serializer The serializer handle\n @param fmt The serialization format (ndpi_serialization_format_json, ndpi_serialization_format_tlv, ndpi_serialization_format_csv)\n @param buffer_size The initial internal buffer_size\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_init_serializer_ll(
        serializer: *mut ndpi_serializer,
        fmt: ndpi_serialization_format,
        buffer_size: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release all allocated data structure.\n @param serializer The serializer handle"]
    pub fn ndpi_term_serializer(serializer: *mut ndpi_serializer);
}
unsafe extern "C" {
    #[doc = " Reset the serializer (cleanup the internal buffer to start a new serialization)\n @param serializer The serializer handle"]
    pub fn ndpi_reset_serializer(serializer: *mut ndpi_serializer);
}
unsafe extern "C" {
    #[doc = " Hint to not create the header (used to avoid creating the header when not used)\n @param serializer The serializer handle"]
    pub fn ndpi_serializer_skip_header(serializer: *mut ndpi_serializer);
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a 32-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_uint32(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a 64-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_uint64(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: u_int64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a 32-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_int32(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a 64-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_int64(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a float value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param format The float value format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_float(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: f32,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a double value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param format The double value format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_double(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: f64,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_string(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a boolean value (JSON/CSV only, not supported by TLV)\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_boolean(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a 32-bit unsigned int and an unterminated string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param vlen The value length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_binary(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        _value: *const ::std::os::raw::c_char,
        vlen: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an unterminated string key and a 32-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_int32(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a 32-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_int32(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an unterminated string key and a 64-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_int64(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a 64-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_int64(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an unterminated string key and a 32-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_uint32(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
        value: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a 32-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_uint32(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a float value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param format The float format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_uint32_format(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: u_int32_t,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an unterminated string key and a 64-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_uint64(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
        value: u_int64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a 64-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_uint64(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: u_int64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an unterminated string key and an unterminated string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @param vlen The value length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_binary(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
        _value: *const ::std::os::raw::c_char,
        vlen: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_string(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param value_len The field value length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_string_len(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        value_len: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and an unterminated string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param vlen The value length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_binary(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        _value: *const ::std::os::raw::c_char,
        vlen: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a raw value (this is a string which is added to the JSON without any quote or escaping)\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param vlen The value length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_raw(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        _value: *const ::std::os::raw::c_char,
        vlen: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an unterminated string key and a float value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @param format The float format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_float(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
        value: f32,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an unterminated string key and a double value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @param format The double format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_double(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
        value: f64,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a a float value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param format The float format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_float(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: f32,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a a double value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param format The double format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_double(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: f64,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an unterminated string key and a boolean value (JSON/CSV only, not supported by TLV)\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_boolean(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
        value: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a string key and a boolean value (JSON/CSV only, not supported by TLV)\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_boolean(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        value: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize a raw record in an array (this is a low-level function and its use is not recommended)\n @param serializer The serializer handle\n @param record The record value\n @param record_len The record length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_raw_record(
        _serializer: *mut ndpi_serializer,
        record: *mut u_char,
        record_len: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize an End-Of-Record (the current object becomes is terminated and added to an array,\n and a new object is created where the next items will be added)\n @param serializer The serializer handle\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_end_of_record(serializer: *mut ndpi_serializer) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize the start of a list with an unterminated string key, where the next serialized items\n will be added (note: keys for the new items are ignored)\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_list_binary(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize the start of a list, where the next serialized items will be added (note: keys for\n the new items are ignored)\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_list(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize the end of a list\n @param serializer The serializer handle\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_end_of_list(serializer: *mut ndpi_serializer) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize the start of a block with an unterminated string key\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_block_binary(
        _serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
        klen: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize the start of a block with a string key\n @param serializer The serializer handle\n @param key The field name or ID\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_block(
        serializer: *mut ndpi_serializer,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize the start of a block with a numeric key\n @param serializer The serializer handle\n @param key The numeric key as 32-bit unsigned integer.\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_block_uint32(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Serialize the end of a block\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_end_of_block(serializer: *mut ndpi_serializer) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the serialized buffer\n @param serializer The serializer handle\n @param buffer_len The buffer length (out)\n @return The buffer"]
    pub fn ndpi_serializer_get_buffer(
        serializer: *mut ndpi_serializer,
        buffer_len: *mut u_int32_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return the current serialized buffer length\n @param serializer The serializer handle\n @return The buffer length"]
    pub fn ndpi_serializer_get_buffer_len(serializer: *mut ndpi_serializer) -> u_int32_t;
}
unsafe extern "C" {
    #[doc = " Return the real internal buffer size (containing the serialized buffer)\n @param serializer The serializer handle\n @return The internal buffer size"]
    pub fn ndpi_serializer_get_internal_buffer_size(serializer: *mut ndpi_serializer) -> u_int32_t;
}
unsafe extern "C" {
    #[doc = " Change the serializer buffer length\n @param serializer The serializer handle\n @param l The new buffer length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serializer_set_buffer_len(
        serializer: *mut ndpi_serializer,
        l: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the configured serialization format\n @param serializer The serializer handle\n @return The serialization format"]
    pub fn ndpi_serializer_get_format(
        serializer: *mut ndpi_serializer,
    ) -> ndpi_serialization_format;
}
unsafe extern "C" {
    #[doc = " Set the CSV separator\n @param serializer The serializer handle\n @param separator The separator"]
    pub fn ndpi_serializer_set_csv_separator(
        serializer: *mut ndpi_serializer,
        separator: ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Return the header automatically built from keys (CSV only)\n @param serializer The serializer handle\n @param buffer_len The buffer length (out)\n @return The header"]
    pub fn ndpi_serializer_get_header(
        serializer: *mut ndpi_serializer,
        buffer_len: *mut u_int32_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Create a snapshot of the internal buffer for later rollback (ndpi_serializer_rollback_snapshot)\n @param serializer The serializer handle"]
    pub fn ndpi_serializer_create_snapshot(serializer: *mut ndpi_serializer);
}
unsafe extern "C" {
    #[doc = " Rollback to the latest snapshot\n @param serializer The serializer handle"]
    pub fn ndpi_serializer_rollback_snapshot(serializer: *mut ndpi_serializer);
}
unsafe extern "C" {
    pub fn ndpi_init_deserializer(
        deserializer: *mut ndpi_serializer,
        serializer: *mut ndpi_serializer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_init_deserializer_buf(
        deserializer: *mut ndpi_serializer,
        serialized_buffer: *mut u_int8_t,
        serialized_buffer_len: u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_get_format(
        _deserializer: *mut ndpi_serializer,
    ) -> ndpi_serialization_format;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_get_item_type(
        deserializer: *mut ndpi_serializer,
        key_type: *mut ndpi_serialization_type,
    ) -> ndpi_serialization_type;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_next(deserializer: *mut ndpi_serializer) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_key_uint32(
        deserializer: *mut ndpi_serializer,
        key: *mut u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_key_string(
        deserializer: *mut ndpi_serializer,
        key: *mut ndpi_string,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_value_uint32(
        deserializer: *mut ndpi_serializer,
        value: *mut u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_value_uint64(
        deserializer: *mut ndpi_serializer,
        value: *mut u_int64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_value_int32(
        deserializer: *mut ndpi_serializer,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_value_int64(
        deserializer: *mut ndpi_serializer,
        value: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_value_float(
        deserializer: *mut ndpi_serializer,
        value: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_value_double(
        deserializer: *mut ndpi_serializer,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_value_string(
        deserializer: *mut ndpi_serializer,
        value: *mut ndpi_string,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_clone_item(
        deserializer: *mut ndpi_serializer,
        serializer: *mut ndpi_serializer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_clone_all(
        deserializer: *mut ndpi_serializer,
        serializer: *mut ndpi_serializer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_json_string_escape(
        src: *const ::std::os::raw::c_char,
        src_len: ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_char,
        dst_max_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_alloc_data_analysis(_max_series_len: u_int16_t) -> *mut ndpi_analyze_struct;
}
unsafe extern "C" {
    pub fn ndpi_alloc_data_analysis_from_series(
        values: *const u_int32_t,
        num_values: u_int16_t,
    ) -> *mut ndpi_analyze_struct;
}
unsafe extern "C" {
    pub fn ndpi_init_data_analysis(s: *mut ndpi_analyze_struct, _max_series_len: u_int16_t);
}
unsafe extern "C" {
    pub fn ndpi_free_data_analysis(d: *mut ndpi_analyze_struct, free_pointer: u_int8_t);
}
unsafe extern "C" {
    pub fn ndpi_reset_data_analysis(d: *mut ndpi_analyze_struct);
}
unsafe extern "C" {
    pub fn ndpi_data_add_value(s: *mut ndpi_analyze_struct, value: u_int64_t);
}
unsafe extern "C" {
    pub fn ndpi_data_window_average(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_window_variance(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_window_stddev(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_average(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_entropy(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_variance(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_stddev(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_mean(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_jitter(s: *mut ndpi_analyze_struct) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_last(s: *mut ndpi_analyze_struct) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_data_min(s: *mut ndpi_analyze_struct) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_data_max(s: *mut ndpi_analyze_struct) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_data_ratio(sent: u_int32_t, rcvd: u_int32_t) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_alloc_rsi(
        s: *mut ndpi_rsi_struct,
        num_learning_values: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_free_rsi(s: *mut ndpi_rsi_struct);
}
unsafe extern "C" {
    pub fn ndpi_rsi_add_value(s: *mut ndpi_rsi_struct, value: u_int32_t) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_hw_init(
        hw: *mut ndpi_hw_struct,
        num_periods: u_int16_t,
        additive_seeasonal: u_int8_t,
        alpha: f64,
        beta: f64,
        gamma: f64,
        significance: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_hw_free(hw: *mut ndpi_hw_struct);
}
unsafe extern "C" {
    pub fn ndpi_hw_add_value(
        hw: *mut ndpi_hw_struct,
        value: u_int64_t,
        forecast: *mut f64,
        confidence_band: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_hw_reset(hw: *mut ndpi_hw_struct);
}
unsafe extern "C" {
    pub fn ndpi_ses_init(
        ses: *mut ndpi_ses_struct,
        alpha: f64,
        significance: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_ses_add_value(
        ses: *mut ndpi_ses_struct,
        _value: f64,
        forecast: *mut f64,
        confidence_band: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_ses_fitting(values: *mut f64, num_values: u_int32_t, ret_alpha: *mut f32);
}
unsafe extern "C" {
    pub fn ndpi_ses_reset(ses: *mut ndpi_ses_struct);
}
unsafe extern "C" {
    pub fn ndpi_md5(data: *const u_char, data_len: usize, hash: *mut u_char);
}
unsafe extern "C" {
    pub fn ndpi_sha256(data: *const u_char, data_len: usize, sha_hash: *mut u_int8_t);
}
unsafe extern "C" {
    pub fn ndpi_crc16_ccit(data: *const ::std::os::raw::c_void, n_bytes: usize) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_crc16_ccit_false(data: *const ::std::os::raw::c_void, n_bytes: usize) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_crc16_xmodem(data: *const ::std::os::raw::c_void, n_bytes: usize) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_crc16_x25(data: *const ::std::os::raw::c_void, n_bytes: usize) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_crc32(
        data: *const ::std::os::raw::c_void,
        length: usize,
        crc: u_int32_t,
    ) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_nearest_power_of_two(x: u_int32_t) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_quick_hash(str_: *const ::std::os::raw::c_uchar, str_len: u_int) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_quick_hash64(str_: *const ::std::os::raw::c_char, str_len: u_int) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_hash_string(str_: *const ::std::os::raw::c_char) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_rev_hash_string(str_: *const ::std::os::raw::c_char) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_hash_string_len(str_: *const ::std::os::raw::c_char, len: u_int) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_murmur_hash(str_: *const ::std::os::raw::c_char, str_len: u_int) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_hex2bin(out: *mut u_char, out_len: u_int, in_: *mut u_char, in_len: u_int)
        -> u_int;
}
unsafe extern "C" {
    pub fn ndpi_bin2hex(out: *mut u_char, out_len: u_int, in_: *mut u_char, in_len: u_int)
        -> u_int;
}
unsafe extern "C" {
    pub fn ndpi_des_init(
        des: *mut ndpi_des_struct,
        alpha: f64,
        beta: f64,
        significance: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_des_add_value(
        des: *mut ndpi_des_struct,
        _value: f64,
        forecast: *mut f64,
        confidence_band: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_des_fitting(
        values: *mut f64,
        num_values: u_int32_t,
        ret_alpha: *mut f32,
        ret_beta: *mut f32,
    );
}
unsafe extern "C" {
    pub fn ndpi_des_reset(des: *mut ndpi_des_struct);
}
unsafe extern "C" {
    pub fn ndpi_jitter_init(
        hw: *mut ndpi_jitter_struct,
        num_periods: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_jitter_free(hw: *mut ndpi_jitter_struct);
}
unsafe extern "C" {
    pub fn ndpi_jitter_add_value(s: *mut ndpi_jitter_struct, value: f32) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_data_ratio2str(ratio: f32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_data_print_window_values(s: *mut ndpi_analyze_struct);
}
unsafe extern "C" {
    pub fn ndpi_validate_url(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        url: *mut ::std::os::raw::c_char,
    ) -> ndpi_risk_enum;
}
unsafe extern "C" {
    pub fn ndpi_is_protocol_detected(proto: ndpi_protocol) -> u_int8_t;
}
unsafe extern "C" {
    pub fn ndpi_serialize_risk(serializer: *mut ndpi_serializer, risk: ndpi_risk);
}
unsafe extern "C" {
    pub fn ndpi_serialize_risk_score(serializer: *mut ndpi_serializer, risk: ndpi_risk_enum);
}
unsafe extern "C" {
    pub fn ndpi_serialize_confidence(
        serializer: *mut ndpi_serializer,
        confidence: ndpi_confidence_t,
    );
}
unsafe extern "C" {
    pub fn ndpi_serialize_proto(
        ndpi_struct: *mut ndpi_detection_module_struct,
        serializer: *mut ndpi_serializer,
        risk: ndpi_risk,
        confidence: ndpi_confidence_t,
        l7_protocol: ndpi_protocol,
    );
}
unsafe extern "C" {
    pub fn ndpi_risk2str(risk: ndpi_risk_enum) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_risk2code(risk: ndpi_risk_enum) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_code2risk(risk: *const ::std::os::raw::c_char) -> ndpi_risk_enum;
}
unsafe extern "C" {
    pub fn ndpi_severity2str(s: ndpi_risk_severity) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_risk2severity(risk: ndpi_risk_enum) -> *mut ndpi_risk_info;
}
unsafe extern "C" {
    pub fn ndpi_risk2score(
        risk: ndpi_risk,
        client_score: *mut u_int16_t,
        server_score: *mut u_int16_t,
    ) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_check_issuerdn_risk_exception(
        ndpi_str: *mut ndpi_detection_module_struct,
        issuerDN: *mut ::std::os::raw::c_char,
    ) -> u_int8_t;
}
unsafe extern "C" {
    pub fn ndpi_check_flow_risk_exceptions(
        ndpi_str: *mut ndpi_detection_module_struct,
        num_params: u_int,
        params: *mut ndpi_risk_params,
    ) -> u_int8_t;
}
unsafe extern "C" {
    pub fn ndpi_hll_init(hll: *mut ndpi_hll, bits: u_int8_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_hll_destroy(hll: *mut ndpi_hll);
}
unsafe extern "C" {
    pub fn ndpi_hll_reset(hll: *mut ndpi_hll);
}
unsafe extern "C" {
    pub fn ndpi_hll_add(
        hll: *mut ndpi_hll,
        data: *const ::std::os::raw::c_char,
        data_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_hll_add_number(hll: *mut ndpi_hll, value: u_int32_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_hll_count(hll: *mut ndpi_hll) -> f64;
}
unsafe extern "C" {
    pub fn ndpi_cm_sketch_init(depth: u_int16_t) -> *mut ndpi_cm_sketch;
}
unsafe extern "C" {
    pub fn ndpi_cm_sketch_add(sketch: *mut ndpi_cm_sketch, element: u_int32_t);
}
unsafe extern "C" {
    pub fn ndpi_cm_sketch_count(sketch: *mut ndpi_cm_sketch, element: u_int32_t) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_cm_sketch_destroy(sketch: *mut ndpi_cm_sketch);
}
unsafe extern "C" {
    pub fn ndpi_popcount_init(h: *mut ndpi_popcount) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_popcount_count(h: *mut ndpi_popcount, buf: *const u_int8_t, buf_len: u_int32_t);
}
unsafe extern "C" {
    pub fn ndpi_mahalanobis_distance(
        x: *const u_int32_t,
        size: u_int32_t,
        u: *const f32,
        i_s: *const f32,
    ) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_init_bin(
        b: *mut ndpi_bin,
        f: ndpi_bin_family,
        num_bins: u_int16_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_free_bin(b: *mut ndpi_bin);
}
unsafe extern "C" {
    pub fn ndpi_clone_bin(b: *mut ndpi_bin) -> *mut ndpi_bin;
}
unsafe extern "C" {
    pub fn ndpi_inc_bin(b: *mut ndpi_bin, slot_id: u_int16_t, val: u_int64_t);
}
unsafe extern "C" {
    pub fn ndpi_set_bin(b: *mut ndpi_bin, slot_id: u_int16_t, value: u_int64_t);
}
unsafe extern "C" {
    pub fn ndpi_get_bin_value(b: *mut ndpi_bin, slot_id: u_int16_t) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_reset_bin(b: *mut ndpi_bin);
}
unsafe extern "C" {
    pub fn ndpi_normalize_bin(b: *mut ndpi_bin);
}
unsafe extern "C" {
    pub fn ndpi_print_bin(
        b: *mut ndpi_bin,
        normalize_first: u_int8_t,
        out_buf: *mut ::std::os::raw::c_char,
        out_buf_len: u_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_bin_similarity(
        b1: *mut ndpi_bin,
        b2: *mut ndpi_bin,
        normalize_first: u_int8_t,
        similarity_max_threshold: f32,
    ) -> f32;
}
unsafe extern "C" {
    pub fn ndpi_cluster_bins(
        bins: *mut ndpi_bin,
        num_bins: u_int16_t,
        num_clusters: u_int8_t,
        cluster_ids: *mut u_int16_t,
        centroids: *mut ndpi_bin,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_kd_create(num_dimensions: u_int) -> *mut ndpi_kd_tree;
}
unsafe extern "C" {
    pub fn ndpi_kd_free(tree: *mut ndpi_kd_tree);
}
unsafe extern "C" {
    pub fn ndpi_kd_clear(tree: *mut ndpi_kd_tree);
}
unsafe extern "C" {
    pub fn ndpi_kd_insert(
        tree: *mut ndpi_kd_tree,
        data_vector: *const f64,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_kd_nearest(
        tree: *mut ndpi_kd_tree,
        data_vector: *const f64,
    ) -> *mut ndpi_kd_tree_result;
}
unsafe extern "C" {
    pub fn ndpi_kd_num_results(res: *mut ndpi_kd_tree_result) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_kd_result_get_item(
        res: *mut ndpi_kd_tree_result,
        user_data: *mut *mut f64,
    ) -> *mut f64;
}
unsafe extern "C" {
    pub fn ndpi_kd_result_free(res: *mut ndpi_kd_tree_result);
}
unsafe extern "C" {
    pub fn ndpi_kd_distance(a1: *mut f64, b2: *mut f64, num_dimensions: u_int) -> f64;
}
unsafe extern "C" {
    pub fn ndpi_btree_init(
        data: *mut *mut f64,
        n_rows: u_int32_t,
        n_columns: u_int32_t,
    ) -> *mut ndpi_btree;
}
unsafe extern "C" {
    pub fn ndpi_btree_query(
        b: *mut ndpi_btree,
        query_data: *mut *mut f64,
        query_data_num_rows: u_int32_t,
        query_data_num_columns: u_int32_t,
        max_num_results: u_int32_t,
    ) -> ndpi_knn;
}
unsafe extern "C" {
    pub fn ndpi_free_knn(knn: ndpi_knn);
}
unsafe extern "C" {
    pub fn ndpi_free_btree(tree: *mut ndpi_btree);
}
unsafe extern "C" {
    pub fn ndpi_find_outliers(
        values: *mut u_int32_t,
        outliers: *mut bool,
        num_values: u_int32_t,
    ) -> u_int;
}
unsafe extern "C" {
    pub fn ndpi_predict_linear(
        values: *mut u_int32_t,
        num_values: u_int32_t,
        predict_periods: u_int32_t,
        prediction: *mut u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_pearson_correlation(
        values_a: *mut u_int32_t,
        values_b: *mut u_int32_t,
        num_values: u_int16_t,
    ) -> f64;
}
unsafe extern "C" {
    pub fn ndpi_is_outlier(
        past_values: *mut u_int32_t,
        num_past_values: u_int32_t,
        value_to_check: u_int32_t,
        threshold: f32,
        lower: *mut f32,
        upper: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_quick_16_byte_hash(in_16_bytes_long: *const u_int8_t) -> u_int32_t;
}
unsafe extern "C" {
    #[doc = " Initialize the hashmap.\n\n @par    h            = pointer to the hash map [in, out]\n\n @return 0 on success, 1 otherwise\n"]
    pub fn ndpi_hash_init(h: *mut *mut ndpi_str_hash) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Free the hashmap.\n\n @par    h            = pointer to the hash map [in, out]\n"]
    pub fn ndpi_hash_free(h: *mut *mut ndpi_str_hash);
}
unsafe extern "C" {
    #[doc = " Search for an entry in the hashmap.\n\n @par    h            = pointer to the hash map [in]\n @par    key          = character string (no '\\0' required) [in]\n @par    key_len      = length of the character string @key [in]\n @par    value        = pointer to a pointer to the value, which contains a\n                        previously added hash entry [in, out]\n\n @return 0 if an entry with that key was found, 1 otherwise\n"]
    pub fn ndpi_hash_find_entry(
        h: *mut ndpi_str_hash,
        key: *mut ::std::os::raw::c_char,
        key_len: u_int,
        value: *mut u_int64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an entry to the hashmap.\n\n @par    h            = pointer to the hash map [in, out]\n @par    key          = character string (no '\\0' required) [in]\n @par    key_len      = length of the character string @key [in]\n @par    value        = value to add [in]\n\n @return 0 if the entry was added, 1 otherwise\n"]
    pub fn ndpi_hash_add_entry(
        h: *mut *mut ndpi_str_hash,
        key: *mut ::std::os::raw::c_char,
        key_len: u_int8_t,
        value: u_int64_t,
    ) -> ::std::os::raw::c_int;
}
pub type ndpi_hash_walk_iter = ::std::option::Option<
    unsafe extern "C" fn(
        key: *mut ::std::os::raw::c_char,
        value64: u_int64_t,
        data: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    pub fn ndpi_hash_walk(
        h: *mut *mut ndpi_str_hash,
        cb: ndpi_hash_walk_iter,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ndpi_hash_get_stats(h: *mut ndpi_str_hash, stats: *mut ndpi_str_hash_stats);
}
unsafe extern "C" {
    pub fn ndpi_get_hash_stats(
        ndpi_struct: *mut ndpi_detection_module_struct,
        hash_type: str_hash_type,
        stats: *mut ndpi_str_hash_stats,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_load_geoip(
        ndpi_str: *mut ndpi_detection_module_struct,
        ip_city_data: *const ::std::os::raw::c_char,
        ip_as_data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_free_geoip(ndpi_str: *mut ndpi_detection_module_struct);
}
unsafe extern "C" {
    pub fn ndpi_get_geoip_asn(
        ndpi_str: *mut ndpi_detection_module_struct,
        ip: *mut ::std::os::raw::c_char,
        asn: *mut u_int32_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_get_geoip_aso(
        ndpi_str: *mut ndpi_detection_module_struct,
        ip: *mut ::std::os::raw::c_char,
        aso: *mut ::std::os::raw::c_char,
        aso_len: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_get_geoip_country_continent(
        ndpi_str: *mut ndpi_detection_module_struct,
        ip: *mut ::std::os::raw::c_char,
        country_code: *mut ::std::os::raw::c_char,
        country_code_len: u_int8_t,
        continent: *mut ::std::os::raw::c_char,
        continent_len: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_get_geoip_country_continent_city(
        ndpi_str: *mut ndpi_detection_module_struct,
        ip: *mut ::std::os::raw::c_char,
        country_code: *mut ::std::os::raw::c_char,
        country_code_len: u_int8_t,
        continent: *mut ::std::os::raw::c_char,
        continent_len: u_int8_t,
        city: *mut ::std::os::raw::c_char,
        city_len: u_int8_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_get_flow_name(flow: *mut ndpi_flow_struct) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_alloc() -> *mut ndpi_bitmap;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_free(b: *mut ndpi_bitmap);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_copy(b: *mut ndpi_bitmap) -> *mut ndpi_bitmap;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_cardinality(b: *mut ndpi_bitmap) -> u_int64_t;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_is_empty(b: *mut ndpi_bitmap) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_set(b: *mut ndpi_bitmap, value: u_int64_t);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_unset(b: *mut ndpi_bitmap, value: u_int64_t);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_isset(b: *mut ndpi_bitmap, value: u_int64_t) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_serialize(
        b: *mut ndpi_bitmap,
        buf: *mut *mut ::std::os::raw::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_deserialize(
        buf: *mut ::std::os::raw::c_char,
        buf_len: usize,
    ) -> *mut ndpi_bitmap;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_and(a: *mut ndpi_bitmap, b_and: *mut ndpi_bitmap);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_and_alloc(a: *mut ndpi_bitmap, b_and: *mut ndpi_bitmap) -> *mut ndpi_bitmap;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_andnot(a: *mut ndpi_bitmap, b_and: *mut ndpi_bitmap);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_or(a: *mut ndpi_bitmap, b_or: *mut ndpi_bitmap);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_or_alloc(a: *mut ndpi_bitmap, b_and: *mut ndpi_bitmap) -> *mut ndpi_bitmap;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_xor(a: *mut ndpi_bitmap, b_xor: *mut ndpi_bitmap);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_optimize(a: *mut ndpi_bitmap);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_iterator_alloc(b: *mut ndpi_bitmap) -> *mut ndpi_bitmap_iterator;
}
unsafe extern "C" {
    pub fn ndpi_bitmap_iterator_free(b: *mut ndpi_bitmap);
}
unsafe extern "C" {
    pub fn ndpi_bitmap_iterator_next(i: *mut ndpi_bitmap_iterator, value: *mut u_int64_t) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_bitmap64_fuse_alloc() -> *mut ndpi_bitmap64_fuse;
}
unsafe extern "C" {
    pub fn ndpi_bitmap64_fuse_set(b: *mut ndpi_bitmap64_fuse, value: u_int64_t) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_bitmap64_fuse_compress(b: *mut ndpi_bitmap64_fuse) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_bitmap64_fuse_isset(b: *mut ndpi_bitmap64_fuse, value: u_int64_t) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_bitmap64_fuse_free(b: *mut ndpi_bitmap64_fuse);
}
unsafe extern "C" {
    pub fn ndpi_bitmap64_fuse_size(b: *mut ndpi_bitmap64_fuse) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_filter_alloc() -> *mut ndpi_filter;
}
unsafe extern "C" {
    pub fn ndpi_filter_add(f: *mut ndpi_filter, value: u_int32_t) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_filter_add_string(f: *mut ndpi_filter, string: *mut ::std::os::raw::c_char)
        -> bool;
}
unsafe extern "C" {
    pub fn ndpi_filter_contains(f: *mut ndpi_filter, value: u_int32_t) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_filter_contains_string(
        f: *mut ndpi_filter,
        string: *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_filter_free(f: *mut ndpi_filter);
}
unsafe extern "C" {
    pub fn ndpi_filter_size(f: *mut ndpi_filter) -> usize;
}
unsafe extern "C" {
    pub fn ndpi_filter_cardinality(f: *mut ndpi_filter) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_domain_classify_alloc() -> *mut ndpi_domain_classify;
}
unsafe extern "C" {
    pub fn ndpi_domain_classify_free(s: *mut ndpi_domain_classify);
}
unsafe extern "C" {
    pub fn ndpi_domain_classify_size(s: *mut ndpi_domain_classify) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_domain_classify_add(
        ndpi_mod: *mut ndpi_detection_module_struct,
        s: *mut ndpi_domain_classify,
        class_id: u_int32_t,
        domain: *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_domain_classify_add_domains(
        ndpi_mod: *mut ndpi_detection_module_struct,
        s: *mut ndpi_domain_classify,
        class_id: u_int32_t,
        file_path: *mut ::std::os::raw::c_char,
    ) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_domain_classify_hostname(
        ndpi_mod: *mut ndpi_detection_module_struct,
        s: *mut ndpi_domain_classify,
        class_id: *mut u_int64_t,
        hostname: *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_binary_bitmap_alloc() -> *mut ndpi_binary_bitmap;
}
unsafe extern "C" {
    pub fn ndpi_binary_bitmap_set(
        b: *mut ndpi_binary_bitmap,
        value: u_int64_t,
        category: u_int8_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_binary_bitmap_compress(b: *mut ndpi_binary_bitmap) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_binary_bitmap_isset(
        b: *mut ndpi_binary_bitmap,
        value: u_int64_t,
        out_category: *mut u_int8_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_binary_bitmap_free(b: *mut ndpi_binary_bitmap);
}
unsafe extern "C" {
    pub fn ndpi_binary_bitmap_size(b: *mut ndpi_binary_bitmap) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_binary_bitmap_cardinality(b: *mut ndpi_binary_bitmap) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_get_flow_risk_info(
        flow: *mut ndpi_flow_struct,
        out: *mut ::std::os::raw::c_char,
        out_len: u_int,
        use_json: u_int8_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Set user data which can later retrieved with `ndpi_get_user_data()`.\n\n @par ndpi_str = the struct created for the protocol detection\n @par user_data = user data pointer you want to retrieve later with `ndpi_get_user_data()`\n"]
    pub fn ndpi_set_user_data(
        ndpi_str: *mut ndpi_detection_module_struct,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get user data which was previously set with `ndpi_set_user_data()`.\n\n @par ndpi_str = the struct created for the protocol detection\n\n @return the user data pointer\n"]
    pub fn ndpi_get_user_data(
        ndpi_str: *mut ndpi_detection_module_struct,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Loads the domain suffixes from the specified path. You need to\n perform this action once\n\n @par ndpi_str = the struct created for the protocol detection\n @par public_suffix_list_path = path of the public_suffix_list path\n\n @return 0 = no error, -1 otherwise\n"]
    pub fn ndpi_load_domain_suffixes(
        ndpi_str: *mut ndpi_detection_module_struct,
        public_suffix_list_path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the domain suffix out of the specified hostname.\n The returned pointer is an offset of the original hostname.\n Note that you need to call ndpi_load_domain_suffixes() before\n calling this function.\n\n @par ndpi_str = the struct created for the protocol detection\n @par hostname = the hostname from which the domain name has to be extracted\n @par suffix_id = the id of the returned domain\n\n @return The host domain name suffic or the host itself if not found.\n"]
    pub fn ndpi_get_host_domain_suffix(
        ndpi_str: *mut ndpi_detection_module_struct,
        hostname: *const ::std::os::raw::c_char,
        suffix_id: *mut u_int64_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the domain (including the TLS) suffix out of the specified hostname.\n The returned pointer is an offset of the original hostname.\n Note that you need to call ndpi_load_domain_suffixes() before\n calling this function.\n\n @par ndpi_str = the struct created for the protocol detection\n @par hostname = the hostname from which the domain name has to be extracted\n\n @return The host domain name or the host itself if not found.\n"]
    pub fn ndpi_get_host_domain(
        ndpi_str: *mut ndpi_detection_module_struct,
        hostname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_set_config(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto: *const ::std::os::raw::c_char,
        param: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ndpi_cfg_error;
}
unsafe extern "C" {
    pub fn ndpi_set_config_u64(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto: *const ::std::os::raw::c_char,
        param: *const ::std::os::raw::c_char,
        value: u64,
    ) -> ndpi_cfg_error;
}
unsafe extern "C" {
    pub fn ndpi_get_config(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto: *const ::std::os::raw::c_char,
        param: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_dump_config(
        ndpi_str: *mut ndpi_detection_module_struct,
        fd: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_dump_host_based_protocol_id(
        ndpi_str: *mut ndpi_detection_module_struct,
        walker: ndpi_hash_walk_iter,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ndpi_dump_host_based_category_id(
        ndpi_str: *mut ndpi_detection_module_struct,
        walker: ndpi_hash_walk_iter,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ndpi_strtonum(
        numstr: *const ::std::os::raw::c_char,
        minval: i64,
        maxval: i64,
        errstrp: *mut *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> i64;
}
unsafe extern "C" {
    pub fn ndpi_vsnprintf(
        str_: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        va_args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_snprintf(
        str_: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_gmtime_r(timep: *const time_t, result: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn ndpi_strrstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_memrchr(
        m: *const ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn ndpi_str_endswith(
        s: *const ::std::os::raw::c_char,
        suffix: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_compress_str(
        in_: *const ::std::os::raw::c_char,
        len: usize,
        out: *mut ::std::os::raw::c_char,
        bufsize: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ndpi_decompress_str(
        in_: *const ::std::os::raw::c_char,
        len: usize,
        out: *mut ::std::os::raw::c_char,
        bufsize: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn ndpi_encode_domain(
        ndpi_str: *mut ndpi_detection_module_struct,
        domain: *mut ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
        out_len: u_int,
    ) -> u_int;
}
unsafe extern "C" {
    pub fn ndpi_quick_encrypt(
        cleartext_msg: *const ::std::os::raw::c_char,
        cleartext_msg_len: u_int16_t,
        encrypted_msg_len: *mut u_int16_t,
        encrypt_key: *mut u_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_quick_decrypt(
        encrypted_msg: *const ::std::os::raw::c_char,
        encrypted_msg_len: u_int16_t,
        decrypted_msg_len: *mut u_int16_t,
        decrypt_key: *mut u_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_fill_randombytes(
        buf: *mut ::std::os::raw::c_uchar,
        buf_len: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn ndpi_print_os_hint(os_hint: ndpi_os) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ndpi_serialize_flow_fingerprint(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        serializer: *mut ndpi_serializer,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_init_address_cache(max_num_entries: u_int32_t) -> *mut ndpi_address_cache;
}
unsafe extern "C" {
    pub fn ndpi_term_address_cache(cache: *mut ndpi_address_cache);
}
unsafe extern "C" {
    pub fn ndpi_address_cache_flush_expired(
        cache: *mut ndpi_address_cache,
        epoch_now: u_int32_t,
    ) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_address_cache_find(
        cache: *mut ndpi_address_cache,
        ip_addr: ndpi_ip_addr_t,
        epoch_now: u_int32_t,
    ) -> *mut ndpi_address_cache_item;
}
unsafe extern "C" {
    pub fn ndpi_address_cache_insert(
        cache: *mut ndpi_address_cache,
        ip_addr: ndpi_ip_addr_t,
        hostname: *mut ::std::os::raw::c_char,
        epoch_now: u_int32_t,
        ttl: u_int32_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_address_cache_dump(
        cache: *mut ndpi_address_cache,
        path: *mut ::std::os::raw::c_char,
        epoch_now: u_int32_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_address_cache_restore(
        cache: *mut ndpi_address_cache,
        path: *mut ::std::os::raw::c_char,
        epoch_now: u_int32_t,
    ) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_cache_address(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ip_addr: ndpi_ip_addr_t,
        hostname: *mut ::std::os::raw::c_char,
        epoch_now: u_int32_t,
        ttl: u_int32_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_cache_address_find(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ip_addr: ndpi_ip_addr_t,
    ) -> *mut ndpi_address_cache_item;
}
unsafe extern "C" {
    pub fn ndpi_cache_address_dump(
        ndpi_struct: *mut ndpi_detection_module_struct,
        path: *mut ::std::os::raw::c_char,
        epoch_now: u_int32_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_cache_address_restore(
        ndpi_struct: *mut ndpi_detection_module_struct,
        path: *mut ::std::os::raw::c_char,
        epoch_now: u_int32_t,
    ) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_cache_address_flush_expired(
        ndpi_struct: *mut ndpi_detection_module_struct,
        epoch_now: u_int32_t,
    ) -> u_int32_t;
}
unsafe extern "C" {
    pub fn ndpi_cache_hostname_ip(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ip_addr: *mut ndpi_ip_addr_t,
        hostname: *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_cache_find_hostname_ip(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ip_addr: *mut ndpi_ip_addr_t,
        hostname: *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_cache_hostname_ip_swap(ndpi_struct: *mut ndpi_detection_module_struct);
}
unsafe extern "C" {
    pub fn ndpi_cache_enable(ndpi_struct: *mut ndpi_detection_module_struct);
}
unsafe extern "C" {
    #[doc = " Checks if the specified protocol identifier can be placed only on the master_protocol field of ndpi_master_app_protocol\n @param ndpi_str nDPI detection module\n @param proto_id nDPI protocol identifier\n @return true if proto_id cannot be used s app_protocol but only on master_protocol, false is it can be used on both fields"]
    pub fn ndpi_is_master_only_protocol(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto_id: u_int16_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Normalizes the ndpi_master_app_protocol by reworking values of the specified proto, placing the master/app protocols\n in the corresponding protocol fields\n @param ndpi_str nDPI detection module\n @param proto_id nDPI protocol identifier\n @return true if the protocok has been modified/normalized, false if proto has not been modified"]
    pub fn ndpi_normalize_protocol(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto: *mut ndpi_master_app_protocol,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_lru_cache_idx_to_name(idx: lru_cache_type) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Finds the first occurrence of the sequence `needle` in the array\n `haystack`.\n\n This function searches for the first occurrence of the sequence `needle` of\n length `needle_len` in the array `haystack` of length `haystack_len`. If\n `haystack` or `needle` is `NULL`, or `haystack_len` is less than\n `needle_len`, or `needle_len` is 0, the function returns `NULL`.\n\n For optimization, if `needle_len` is 1, the `memchr` function is used.\n\n @param haystack Pointer to the array in which the search is performed.\n @param haystack_len Length of the `haystack` array.\n @param needle Pointer to the array to be searched for in `haystack`.\n @param needle_len Length of the `needle` array.\n @return Pointer to the first occurrence of `needle` in `haystack` or `NULL`\n if `needle` is not found."]
    pub fn ndpi_memmem(
        haystack: *const ::std::os::raw::c_void,
        haystack_len: usize,
        needle: *const ::std::os::raw::c_void,
        needle_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Copies src string to dst buffer with length limit\n\n Copies the string src into dst buffer, limiting the copy length by dst_len.\n Handles both null-terminated and non null-terminated strings based on\n src_len. Ensures null-termination in dst if dst_len > 0.\n\n @param dst Destination buffer\n @param src Source string\n @param dst_len Size of dst buffer\n @param src_len Length of src string\n\n @return Length of src string"]
    pub fn ndpi_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_len: usize,
        src_len: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Converts a string from ISO 8859 to UTF-8\n\n @param in String to convert\n @param in_len Source string length\n @param out Destination string buffer (UTF-8)\n @param out_len Length of destination string buffer. It must be at least (2*in_len)+1\n\n @return The destination string buffer"]
    pub fn ndpi_str_to_utf8(
        in_: *mut u_char,
        in_len: u_int,
        out: *mut u_char,
        out_len: u_int,
    ) -> *mut u_char;
}
unsafe extern "C" {
    #[doc = " Performs a case-insensitive comparison of two memory regions\n\n @par    s1    Pointer to the first memory region\n @par    s2    Pointer to the second memory region\n @par    n     Number of bytes to compare\n @return       < 0 if s1 is less than s2 in a case-insensitive comparison\n               = 0 if s1 matches s2 in a case-insensitive comparison\n               > 0 if s1 is greater than s2 in a case-insensitive comparison\n               If s1 is NULL and s2 is not, returns -1\n               If s2 is NULL and s1 is not, returns 1\n               If both are NULL, returns 0\n\n This function works similarly to memcmp() but performs case-insensitive\n comparison."]
    pub fn ndpi_memcasecmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_bitmask_alloc(b: *mut ndpi_bitmask, max_bits: u_int16_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_bitmask_free(b: *mut ndpi_bitmask);
}
unsafe extern "C" {
    pub fn ndpi_bitmask_set(b: *mut ndpi_bitmask, bit: u_int16_t);
}
unsafe extern "C" {
    pub fn ndpi_bitmask_clear(b: *mut ndpi_bitmask, bit: u_int16_t);
}
unsafe extern "C" {
    pub fn ndpi_bitmask_is_set(b: *const ndpi_bitmask, bit: u_int16_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ndpi_bitmask_set_all(b: *mut ndpi_bitmask);
}
unsafe extern "C" {
    pub fn ndpi_bitmask_reset(b: *mut ndpi_bitmask);
}
unsafe extern "C" {
    pub fn ndpi_check_is_numeric_ip(host: *mut ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_get_master_proto(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> u_int16_t;
}
unsafe extern "C" {
    pub fn ndpi_init_ranking(
        rank: *mut ndpi_ranking,
        max_num_items: u_int16_t,
        num_epochs: u_int16_t,
    );
}
unsafe extern "C" {
    pub fn ndpi_term_ranking(rank: *mut ndpi_ranking);
}
unsafe extern "C" {
    pub fn ndpi_serialize_ranking(
        rank: *mut ndpi_ranking,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_deserialize_ranking(
        rank: *mut ndpi_ranking,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ndpi_print_ranking(rank: *mut ndpi_ranking);
}
unsafe extern "C" {
    pub fn ndpi_ranking_add_epoch(
        rank: *mut ndpi_ranking,
        epoch: u_int32_t,
        entries: *mut ndpi_ranking_epoch_entry,
        num_epoch_entries: u_int16_t,
        curr_ranking: *mut ndpi_ranking_change,
        prev_ranking: *mut ndpi_ranking_change,
        prev_ranking_epoch: *mut u_int32_t,
    ) -> u_int16_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_obfuscated_heuristic_state {
    pub _address: u8,
}
